<html data-bs-theme="dark" class="dark-mode w-100">

<head>
    <title>"placeholder_dashboard_title"</title>
    <!-- ChartJs import -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>

    <!-- ChartJs Datalabel plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- ChartJs timeline plugin (helps create time axis) -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- ChartJs boxplot plugin (for time deviation graph) -->
    <script type="text/javascript"
        src="https://unpkg.com/@sgratzl/chartjs-chart-boxplot@3.6.0/build/index.umd.min.js"></script>

    <!-- ChartJs heatmap/matrix plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>

    <!-- DataTables and Bootstrap imports -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css"
        rel="stylesheet" />
    <link href="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.js"></script>

    <!-- Pako that is used to decompress the initial data -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon"
        href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAqAAAAAAAAAAAAAAAAAAAALIAAAD/AAAA4AAAANwAAADcAAAA3AAAANwAAADcAAAA3AAAANwAAADcAAAA4AAAAP8AAACxAAAAAAAAAKYAAAD/AAAAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/AAAA/wAAAKkAAAD6AAAAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAD/AAAA+gAAAMMAAAAAAAAAAgAAAGsAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAADAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAIsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAANEAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAAAAAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAFAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAADwAAAB8AAAAAAAAAGAAAABcAAAAAAAAAH8AAABKAAAAAAAAAAAAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAADCAAAA/wAAACkAAADqAAAA4QAAAAAAAAD7AAAA/wAAALAAAAAGAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAIwAAAP4AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAMkAAAD/AAAAigAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAAAAAAAIAAAAcAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAA2gAAAP8AAAD7AAAAywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAD/AAAAqwAAAP8AAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALIAAAD/AAAAsgAAAAAAAAC5AAAA/wAAAMoAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMkAAAD/AAAAvAAAAAAAAAAAAAAAAAAAAKwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAArQAAAAAAAAAAwAMAAIABAAAf+AAAP/wAAD/8AAAgBAAAP/wAAD/8AAA//AAAJIwAADHEAAA//AAAP/wAAB/4AACAAQAAwAMAAA==" />

    <style>
        /* LIGHT MODE STYLING */
        body {
            background-color: #eee;
        }

        .border-bottom {
            border-color: rgba(0, 0, 0, 0.175) !important;
        }

        .fullscreen,
        .sticky-top,
        body {
            background-color: #eee;
        }

        #version {
            color: #eee;
        }

        .form-switch .form-check-input:not(:checked) {
            background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='black'/></svg>");
            border-color: black;
        }

        .information[data-title]::after {
            background-color: white;
            color: black;
        }

        .stat-label {
            font-size: 1rem;
            color: darkgrey;
        }

        .white-text {
            color: black;
        }

        /* DARK MODE STYLING */
        .dark-mode :root {
            color-scheme: dark;
        }

        .dark-mode .canvas {
            background: rgba(30, 41, 59, 0.9);
        }

        .dark-mode .fullscreen {
            background: rgba(30, 41, 59, 1);
        }

        .dark-mode .modal-content {
            background: #0f172a;
        }

        .dark-mode .border-bottom {
            border-color: rgba(255, 255, 255, 0.15) !important;
        }

        .dark-mode .sticky-top,
        .dark-mode .card,
        .dark-mode body,
        .dark-mode .modal-dialog {
            background: #0f172a;
            color: #eee;
        }

        .dark-mode .list-group-item:not(.disabled),
        .dark-mode .form-label,
        .dark-mode .form-control,
        .dark-mode .form-select,
        .dark-mode #version {
            color: #eee;
        }

        .dark-mode .list-group-item .disabled {
            color: rgba(173, 181, 189, 0.75);
        }

        .dark-mode .form-switch .form-check-input:not(:checked) {
            background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='white'/></svg>");
            border-color: #eee;
        }

        .dark-mode .table>:not(caption)>*>* {
            color: #eee;
        }

        .dark-mode .collapse-icon {
            color: #eee;
        }

        .dark-mode .information[data-title]::after {
            background-color: #0f172a;
            color: #eee;
        }

        .dark-mode .stat-label {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        .dark-mode .white-text {
            color: #eee;
        }

        /* GENERAL STYLING */
        :root {
            font-family: Helvetica, sans-serif;
        }

        h4,
        h6 {
            margin-bottom: 0rem;
        }

        body.lock-scroll {
            overflow: hidden;
        }

        .information[data-title]:hover::after {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.2s ease-in-out;
        }

        .information[data-title]::after {
            content: attr(data-title);
            white-space: pre-line;
            font-size: 0.95rem;
            position: absolute;
            padding: 8px 12px;
            border-radius: 8px;
            top: calc(100% + 8px);
            right: -90px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            border: 1px solid #1e293b;
            z-index: 9999;
            visibility: hidden;
            max-width: min(90vw, 360px);
            width: max-content;
            overflow-wrap: break-word;
            text-align: left;
            box-sizing: border-box;
        }

        .information[data-title] {
            position: relative;
            cursor: pointer;
        }

        .canvas {
            min-width: 400px;
            width: 700px;
            height: 540px;
            text-align: center;
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .canvas:not(.fullscreen) .donut-charts {
            height: 450px;
        }

        .canvas.fullscreen .donut-charts {
            height: 100%;
        }

        .canvas:not(.fullscreen) {
            margin: 1rem;
        }

        .canvas-vertical,
        .canvas.fullscreen {
            overflow-y: auto;
        }

        canvas {
            padding-bottom: 1.5rem;
        }

        .canvas.fullscreen canvas,
        .canvas.fullscreen .donut-charts {
            height: calc(100% - 51px) !important;
        }

        .card {
            margin-top: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .sticky-top {
            padding-top: 6px;
            margin: 0 -0.75rem 0 -0.75rem;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
        }

        .dt-container {
            margin-top: 20px;
        }

        .stats {
            float: right;
            text-align: right;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .fullscreen {
            position: fixed;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            z-index: 10;
            padding: 11px 20px 70px 20px;
            border-radius: 0px;
        }

        .selectBox {
            position: relative;
        }

        .selectBox select {
            width: 100%;
        }

        .overSelect {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        #checkboxes {
            display: none;
            position: absolute;
            z-index: 2;
        }

        #checkboxes label {
            display: block;
        }

        .border,
        .controls {
            min-height: 165px;
        }

        .hideItemText {
            margin-right: auto;
        }

        .moveUp {
            margin: 5px 2px 0px 2px;
            padding: 2px 1px 2px 1px;
            height: 16px !important;
        }

        .moveDown {
            margin: 5px 2px 0px 2px;
            padding: 3px 1px 2px 1px;
            height: 16px !important;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .fullscreen .stat-value {
            font-size: 4rem;
        }

        .fullscreen .stat-label {
            font-size: 2rem;
        }

        .green-text {
            color: rgba(151, 189, 97, 0.9);
        }

        .red-text {
            color: rgba(206, 62, 1, 0.9);
        }

        .yellow-text {
            color: rgba(254, 216, 79, 0.9);
        }

        .blue-text {
            color: dodgerblue;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="sticky-top" id="filterSection">
            <div class="row border-bottom pb-1" id="filterRowPadding">
                <div class="col-10">
                    <div class="row">
                        <div class="col-auto">
                            <h1>"placeholder_dashboard_title"</h1>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-auto">
                            <label class="form-label form-label-sm" for="runs" id="runsLabel">Runs</label>
                            <select class="form-select form-select-sm" id="runs"></select>
                        </div>
                        <div class="col-auto">
                            <div class="selectBox" id="selectRunTags">
                                <label class="form-label form-label-sm" for="runTag" id="runTagLabel">Run Tags</label>
                                <select class="form-select form-select-sm">
                                    <option>Select Tags</option>
                                </select>
                                <div class="overSelect"></div>
                            </div>
                            <div id="checkboxes">
                                <ul class="list-group" id="runTag"></ul>
                            </div>
                        </div>
                        <div class="col-auto">
                            <label class="form-label form-label-sm" for="fromDate" id="fromDateLabel">From Date</label>
                            <input class="form-control form-control-sm" id="fromDate" type="date" />
                        </div>
                        <div class="col-auto">
                            <label class="form-label form-label-sm" for="fromTime" id="fromTimeLabel">From Time</label>
                            <input class="form-control form-control-sm" id="fromTime" type="time" />
                        </div>
                        <div class="col-auto">
                            <label class="form-label form-label-sm" for="toDate" id="toDateLabel">To Date</label>
                            <input class="form-control form-control-sm" id="toDate" type="date" />
                        </div>
                        <div class="col-auto">
                            <label class="form-label form-label-sm" for="toTime" id="toTimeLabel">To Time</label>
                            <input class="form-control form-control-sm" id="toTime" type="time" />
                        </div>
                        <div class="col-auto">
                            <label class="form-label form-label-sm" for="amount" id="amountLabel"
                                title="Amount of runs that are shown. Only the most recent x runs are shown after applying the other filters.">Run
                                Amount</label>
                            <input class="form-control form-control-sm" type="number" min=0 id="amount"
                                title="Amount of runs that are shown. Only the most recent x runs are shown after applying the other filters."
                                value="10">
                        </div>
                        <div class="col-auto d-flex">
                            <button class="btn btn-outline-light btn-sm mt-auto" id="resetFilters">Reset
                                Filters</button>
                        </div>
                        <div class="col-auto d-flex">
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto" data-bs-toggle="modal"
                                data-bs-target="#hideModal" id="customizeView">
                                Settings
                            </button>
                        </div>
                        <div class="col-auto btn-group" role="group" id="sectionIndicator">
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto"
                                data-target="runStatisticsSection">Runs</button>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto"
                                data-target="suiteStatisticsSection">Suites</button>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto"
                                data-target="testStatisticsSection">Tests</button>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto"
                                data-target="keywordStatisticsSection">Keywords</button>
                        </div>
                        <div class="col-auto mt-auto">
                            <a href="/">
                                <button class="btn btn-outline-light btn-sm" id="openDashboard" hidden>Open Admin
                                    Page</button>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="col-2 stats pb-1">
                    <span id="stats"></span>
                </div>
            </div>
        </div>

        <div class="text-center mt-5" id="loading" style="display: none;">
            <div class="spinner-border" style="width: 5rem; height: 5rem;" role="status">
                <span class="sr-only"></span>
            </div>
        </div>

        <div class="card" id="runStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="runDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#runData" aria-expanded="true" aria-controls="runData"></div>
                    </div>
                    <div class="col">
                        <h4 id="runTitle">Statistics</h4>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card runData -->
            <div id="runDataHiddenTemp" hidden></div>
            <div id="runDataHidden" hidden>
                <!-- Run Statistics -->
                <div class="col canvas pb-5" id="runStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="runStatisticsGraphPercentages">Percentage</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="runStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatisticsClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runStatisticsInformation"></button>
                    <canvas id="runStatisticsGraph"></canvas>
                </div>
                <!-- Run Donuts -->
                <div class="col canvas pb-5" id="runDonutCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDonutGraphDonut">Donut</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDonutFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDonutClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runDonutInformation"></button>
                    <div class="row donut-charts w-100 h-100">
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="runDonutGraph" class="w-100 h-100"></canvas>
                        </div>
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="runDonutTotalGraph" class="w-100 h-100"></canvas>
                        </div>
                    </div>
                </div>
                <!-- Run Stats -->
                <div class="col canvas pb-5" id="runStatsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatsGraphStats">Stats</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatsClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runStatsInformation"></button>
                    <div class="w-100 h-100">
                        <div class="d-flex flex-column justify-content-between h-75 mt-5">
                            <div class="row text-center mb-4">
                                <div class="col">
                                    <div class="stat-label">Executed Runs</div>
                                    <div class="stat-value blue-text" id="totalRuns">5</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Executed Suites</div>
                                    <div class="stat-value blue-text" id="totalSuites">53</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Executed Tests</div>
                                    <div class="stat-value blue-text" id="totalTests">31513</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Executed Keywords</div>
                                    <div class="stat-value blue-text" id="totalKeywords">333333</div>
                                </div>
                            </div>
                            <div class="row text-center mb-4">
                                <div class="col">
                                    <div class="stat-label">Unique Tests</div>
                                    <div class="stat-value white-text" id="totalUniqueTests">355</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Passed</div>
                                    <div class="stat-value green-text" id="totalPassed">1111</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Failed</div>
                                    <div class="stat-value red-text" id="totalFailed">1343143</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Skipped</div>
                                    <div class="stat-value yellow-text" id="totalSkipped">431</div>
                                </div>
                            </div>
                            <div class="row text-center">
                                <div class="col">
                                    <div class="stat-label">Total Run Time</div>
                                    <div class="stat-value white-text" id="totalRunTime">34551</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Avg Run Time</div>
                                    <div class="stat-value white-text" id="averageRunTime">14134</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Avg Test Time</div>
                                    <div class="stat-value white-text" id="averageTestTime">134</div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Avg Run Pass Rate</div>
                                    <div class="stat-value green-text" id="averagePassRate">111</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Run Duration -->
                <div class="col canvas pb-5" id="runDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="runDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDurationClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runDurationInformation"></button>
                    <canvas id="runDurationGraph"></canvas>
                </div>
                <!-- Run Heatmap -->
                <div class="col canvas pb-5" id="runHeatmapCanvas">
                    <div class="btn-group">
                        <label class="form-check-label mb-3" for="heatMapTestType">Status</label>
                    </div>
                    <div class="btn-group">
                        <select class="form-select form-select-sm" id="heatMapTestType" style="margin-bottom:12px">
                            <option value="All">All</option>
                            <option value="Passed">Passed</option>
                            <option value="Failed">Failed</option>
                            <option value="Skipped">Skipped</option>
                        </select>
                    </div>
                                      <div class="btn-group">
                        <label class="form-check-label mb-3" for="heatMapHour">Hour</label>
                    </div>
                    <div class="btn-group">
                        <select class="form-select form-select-sm" id="heatMapHour" style="margin-bottom:12px">
                            <option value="All">All</option>
                            <option value="0">00:00</option>
                            <option value="1">01:00</option>
                            <option value="2">02:00</option>
                            <option value="3">03:00</option>
                            <option value="4">04:00</option>
                            <option value="5">05:00</option>
                            <option value="6">06:00</option>
                            <option value="7">07:00</option>
                            <option value="8">08:00</option>
                            <option value="9">09:00</option>
                            <option value="10">10:00</option>
                            <option value="11">11:00</option>
                            <option value="12">12:00</option>
                            <option value="13">13:00</option>
                            <option value="14">14:00</option>
                            <option value="15">15:00</option>
                            <option value="16">16:00</option>
                            <option value="17">17:00</option>
                            <option value="18">18:00</option>
                            <option value="19">19:00</option>
                            <option value="20">20:00</option>
                            <option value="21">21:00</option>
                            <option value="22">22:00</option>
                            <option value="23">23:00</option>
                        </select>
                    </div>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runHeatmapGraphHeatmap">Heatmap</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runHeatmapFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runHeatmapClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runHeatmapInformation"></button>
                    <canvas id="runHeatmapGraph"></canvas>
                </div>
                <!-- Run Table -->
                <div class="col" id="runTableCanvas">
                    <table class="table table-striped" id="runTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="runData"></div>
        </div>

        <div class="card" id="suiteStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="suiteDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#suiteData" aria-expanded="true" aria-controls="suiteData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="suiteTitle">Suite Statistics</h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteFolder">Folder: </label>
                        </div>
                        <div class="btn-group">
                            <p class="form-label mt-2" id="suiteFolder">All</p>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <button class="btn btn-outline-light btn-sm mt-1" id="resetSuiteFolder">Reset
                                Folder</button>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectSuites">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectSuites"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="useSuitePathsSuiteSection">Use Suite
                                Paths</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch"
                                id="useSuitePathsSuiteSection" />
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card suiteData -->
            <div id="suiteDataHiddenTemp" hidden></div>
            <div id="suiteDataHidden" hidden>
                <!-- Suite Folder Donuts -->
                <div class="col canvas pb-5" id="suiteFolderDonutCanvas">
                    <div class="btn-group me-1">
                        <label class="form-check-label mb-3" for="onlyFailedFolders">Only Failed Folders</label>
                    </div>
                    <div class="btn-group form-switch me-1">
                        <input class="form-check-input mb-3" type="checkbox" role="switch" id="onlyFailedFolders">
                    </div>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteFolderDonutGoUp">Go Up</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteFolderDonutGraphDonut">Donut</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteFolderDonutFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteFolderDonutClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="suiteFolderDonutInformation"></button>
                    <div class="row donut-charts w-100 h-100">
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="suiteFolderDonutGraph" class="w-100 h-100"></canvas>
                        </div>
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="suiteFolderFailDonutGraph" class="w-100 h-100"></canvas>
                        </div>
                    </div>
                </div>
                <!-- Suite Statistics -->
                <div class="col canvas pb-5" id="suiteStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphPercentages">Percentage</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteStatisticsClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="suiteStatisticsInformation"></button>
                    <canvas id="suiteStatisticsGraph"></canvas>
                </div>
                <!-- Suite Duration -->
                <div class="col canvas pb-5" id="suiteDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteDurationClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="suiteDurationInformation"></button>
                    <canvas id="suiteDurationGraph"></canvas>
                </div>
                <!-- Suite Most Failed -->
                <div class="col canvas pb-5" id="suiteMostFailedCanvas">
                    <div id="suiteMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="suiteMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="suiteMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="suiteMostFailedInformation"></button>
                        <canvas id="suiteMostFailedGraph"></canvas>
                    </div>
                </div>
                <!-- Suite Table -->
                <div class="col" id="suiteTableCanvas">
                    <table class="table table-striped" id="suiteTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="suiteData"></div>
        </div>

        <div class="card" id="testStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="testDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#testData" aria-expanded="true" aria-controls="testData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="testTitle">Test Statistics</h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectTests">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectTests"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="useSuitePathsTestSection">Use Suite
                                Paths</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch"
                                id="useSuitePathsTestSection" />
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testSelect">Test</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testSelect"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testTagsSelect">Test Tags</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testTagsSelect"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card keywordData -->
            <div id="testDataHiddenTemp" hidden></div>
            <div id="testDataHidden" hidden>
                <!-- Test Statistics -->
                <div class="col canvas canvas-vertical" id="testStatisticsCanvas">
                    <div id="testStatisticsVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testStatisticsGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testStatisticsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testStatisticsClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testStatisticsInformation"></button>
                        <canvas id="testStatisticsGraph"></canvas>
                    </div>
                </div>
                <!-- Test Duration -->
                <div class="col canvas pb-5" id="testDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="testDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="testDurationInformation"></button>
                    <canvas id="testDurationGraph"></canvas>
                </div>
                <!-- Test Duration Deviation -->
                <div class="col canvas pb-5" id="testDurationDeviationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="testDurationDeviationGraphBar">Boxplot</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="testDurationDeviationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationDeviationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="testDurationDeviationInformation"></button>
                    <canvas id="testDurationDeviationGraph"></canvas>
                </div>
                <!-- Test Messages -->
                <div class="col canvas pb-5" id="testMessagesCanvas">
                    <div id="testMessagesVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMessagesGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMessagesGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMessagesFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMessagesClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testMessagesInformation"></button>
                        <canvas id="testMessagesGraph"></canvas>
                    </div>
                </div>
                <!-- Test Most Flaky -->
                <div class="col canvas pb-5" id="testMostFlakyCanvas">
                    <div id="testMostFlakyVertical">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-3" for="ignoreSkips">Ignore Skips</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-3" type="checkbox" role="switch" id="ignoreSkips">
                        </div>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFlakyGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFlakyGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFlakyFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFlakyClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testMostFlakyInformation"></button>
                        <canvas id="testMostFlakyGraph"></canvas>
                    </div>
                </div>
                <!-- Test Recent Most Flaky -->
                <div class="col canvas pb-5" id="testRecentMostFlakyCanvas">
                    <div id="testRecentMostFlakyVertical">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-3" for="ignoreSkipsRecent">Ignore Skips</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-3" type="checkbox" role="switch" id="ignoreSkipsRecent">
                        </div>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFlakyGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFlakyGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFlakyFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testRecentMostFlakyClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testRecentMostFlakyInformation"></button>
                        <canvas id="testRecentMostFlakyGraph"></canvas>
                    </div>
                </div>
                <!-- Test Most Failed -->
                <div class="col canvas pb-5" id="testMostFailedCanvas">
                    <div id="testMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testMostFailedInformation"></button>
                        <canvas id="testMostFailedGraph"></canvas>
                    </div>
                </div>
                <!-- Test Recent Most Failed -->
                <div class="col canvas pb-5" id="testRecentMostFailedCanvas">
                    <div id="testRecentMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testRecentMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testRecentMostFailedInformation"></button>
                        <canvas id="testRecentMostFailedGraph"></canvas>
                    </div>
                </div>
                <!-- Test Table -->
                <div class="col" id="testTableCanvas">
                    <table class="table table-striped" id="testTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="testData"></div>
        </div>

        <div class="card" id="keywordStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="keywordDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#keywordData" aria-expanded="true" aria-controls="keywordData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="keywordTitle">Keyword Statistics</h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="keywordSelect">Keyword</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="keywordSelect"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card keywordData -->
            <div id="keywordDataHiddenTemp" hidden></div>
            <div id="keywordDataHidden" hidden>
                <!-- Keyword Statistics -->
                <div class="col canvas pb-5" id="keywordStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphPercentages">Percentage</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordStatisticsClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordStatisticsInformation"></button>
                    <canvas id="keywordStatisticsGraph"></canvas>
                </div>
                <!-- Keyword Times Run -->
                <div class="col canvas pb-5" id="keywordTimesRunCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTimesRunGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTimesRunGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTimesRunFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTimesRunClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordTimesRunInformation"></button>
                    <canvas id="keywordTimesRunGraph"></canvas>
                </div>
                <!-- Keyword Total Duration -->
                <div class="col canvas pb-5" id="keywordTotalDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTotalDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTotalDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTotalDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTotalDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordTotalDurationInformation"></button>
                    <canvas id="keywordTotalDurationGraph"></canvas>
                </div>
                <!-- Keyword Average Duration -->
                <div class="col canvas pb-5" id="keywordAverageDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordAverageDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordAverageDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordAverageDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordAverageDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordAverageDurationInformation"></button>
                    <canvas id="keywordAverageDurationGraph"></canvas>
                </div>
                <!-- Keyword Min Duration -->
                <div class="col canvas pb-5" id="keywordMinDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMinDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMinDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMinDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMinDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordMinDurationInformation"></button>
                    <canvas id="keywordMinDurationGraph"></canvas>
                </div>
                <!-- Keyword Max Duration -->
                <div class="col canvas pb-5" id="keywordMaxDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMaxDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMaxDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMaxDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMaxDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordMaxDurationInformation"></button>
                    <canvas id="keywordMaxDurationGraph"></canvas>
                </div>
                <!-- Keyword Most Failed -->
                <div class="col canvas pb-5" id="keywordMostFailedCanvas">
                    <div id="keywordMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="keywordMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="keywordMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="keywordMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="keywordMostFailedInformation"></button>
                        <canvas id="keywordMostFailedGraph"></canvas>
                    </div>
                </div>
                <!-- Keyword Table -->
                <div class="col" id="keywordTableCanvas">
                    <table class="table table-striped" id="keywordTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="keywordData"></div>
        </div>

        <!-- Modal for hiding graphs/sections -->
        <div class="modal fade" id="hideModal" tabindex="-1" aria-labelledby="hideModalLabel" data-bs-backdrop="static">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="hideModalLabel">Settings</h1>
                        <div>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto" data-bs-dismiss="modal"
                                id="resetGraphConfig">Reset View</button>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto ms-3"
                                data-bs-dismiss="modal" id="saveSettings">Save</button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="row border-bottom">
                            <h2>General</h2>
                        </div>
                        <div class="row mt-2">
                            <div class="col-6 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleTheme">Theme: Dark Mode</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleTheme" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleLegends">Graphs: Show
                                    Legends</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleLegends" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleLabels">Graphs: Show Run Start/Alias
                                    Labels On Axes</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleLabels" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleAliases">Graphs: Show Alias Labels
                                    (Defaults
                                    to Run Start Labels)</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleAliases" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleMilliseconds">Graphs: Show
                                    Milliseconds Run Start Labels</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch"
                                    id="toggleMilliseconds" />
                            </div>
                        </div>
                        <div class="row pb-4">
                            <div class="col-6 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleMaxGraphsPerRow">Graphs: Maximum Graphs
                                    Per Row</label>
                            </div>
                            <div class="col-auto ps-0 mt-1">
                                <select class="form-select form-select-sm" id="toggleMaxGraphsPerRow">
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
                                </select>
                            </div>
                        </div>
                        <div class="row border-bottom pt-1">
                            <h2>Customize View</h2>
                        </div>
                        <div class="row mt-2">
                            <div class="col">
                                <h4 class="ms-1">Show Sections</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="sectionShow" class="list-group list-group-numbered"></ol>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm" id="sectionRight"></button>
                                    <button class="btn btn-sm" id="sectionLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4 class="ms-1">Hide Sections</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="sectionHide" class="list-group"></ol>
                                </div>
                            </div>
                            <div class="col">
                                <h4 class="ms-1">Show Graphs</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="graphShow" class="list-group list-group-numbered"></ol>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm" id="graphRight"></button>
                                    <button class="btn btn-sm" id="graphLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4 class="ms-1">Hide Graphs</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="graphHide" class="list-group"></ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /////////////////////////////
        // GLOBAL VARIABLE SECTION //
        /////////////////////////////

        // collapse/expand buttons icons/svgs
        const arrowRight =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g><path fill="currentColor" d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const arrowRightSmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><g><path fill="currentColor" d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const arrowDown =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowDownSmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowLeft =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g transform="scale(-1,1) translate(-52,0)"><path fill="currentColor" d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"/></g></svg>';
        const arrowDownVerySmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="8px" height="8px" viewBox="0 0 52 52"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowUpVerySmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="8px" height="8px" viewBox="0 0 52 52" transform="matrix(-1,1.2246467991473532e-16,-1.2246467991473532e-16,-1,0,0)"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"></path></svg>';

        // information svg
        const informationSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="21" fill="currentColor" class="bi bi-info-circle" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16" /><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0" /></svg>';
        const informationTitles = {
            runStatisticsInformation: `This graph shows the statistics of the runs represented in multiple formats:
- Percentages: Displays the distribution of passed/failed/skipped tests per run, where 100% equals all tests combined.
- Amount: Displays the actual number of passed/failed/skipped tests per run.
- Line: Displays the same data but over a time axis, useful for spotting failure patterns on specific dates or times.`,

            runDonutInformation: `This graph contains two donut charts:
- The first donut displays the total percentage of passed, failed, and skipped tests across all runs.
- The second donut displays the same breakdown, but only for the most recent run.`,

            runStatsInformation: `This section provides key statistics:
- Executed: Total counts of Runs, Suites, Tests, and Keywords that have been executed.
- Unique Tests: Displays the number of distinct test cases across all runs.
- Outcomes: Total Passed, Failed, and Skipped tests, including their percentages relative to the full test set.
- Duration: Displays the cumulative runtime of all runs, the average runtime per run, and the average duration of individual tests.
- Pass Rate: Displays the average run-level pass rate, helping evaluate overall reliability over time.`,

            runDurationInformation: `This graph visualizes the duration of each run:
- Bar: Displays total run durations represented as vertical bars.
- Line: Displays the same data but over a time axis for clearer trend analysis.`,

            runHeatmapInformation: `This graph visualizes a heatmap of when tests are executed the most:
- All: Displays how many tests ran during the hours or minutes of the week days.
- Passed: Displays the same data but only passed tests.
- Failed: Displays the same data but only failed tests.
- Skipped: Displays the same data but only skipped tests.
- Hour: Displays only that hour so you get insights per minute.`,

            suiteFolderDonutInformation: `This graph contains two donut charts:
- The first donut displays the top-level folders of the suites and the amount of tests each folder contains.
- The second donut displays the same folder structure but only for the most recent run and only includes failed tests.
- Clicking on a folder updates the chart with the subfolders/suites it contains.
- Navigating folders also updates Suite Statistics and Suite Duration.
- "Go Up" navigates to the parent folder level.
- "Only Failed Folders" filters to show only folders with failing tests.`,

            suiteStatisticsInformation: `This graph provides suite-level statistics in three formats:
- Percentages: Displays the passed/failed/skipped rate of test suites per run.
- Amount: Displays the actual number of passed/failed/skipped suites per run.
- Line: Displays the same data but over a time axis, useful for spotting failure patterns on specific dates or times.`,

            suiteDurationInformation: `This graph visualizes the duration of each suite:
- Bar: Displays total suite durations represented as vertical bars.
- Line: Displays the same data but over a time axis for clearer trend analysis.`,

            suiteMostFailedInformation: `This graph highlights the test suites with the most failures:
- Bar: Displays suites ranked by number of failures represented as vertical bars.
- Timeline: Displays when failures occurred to identify clustering over time.
- The default view shows the Top 10 most failed suites; fullscreen expands this to the Top 50.`,

            testStatisticsInformation: `This graph displays the statistics of the tests in a timeline format.`,

            testDurationInformation: `This graph tracks how long individual tests take to run:
- Bar: Displays test durations represented as vertical bars.
- Line: Displays the same data but over a time axis for clearer trend analysis.`,

            testDurationDeviationInformation: `This boxplot chart displays how much test durations deviate from the average, represented as vertical bars.
It helps identify tests with inconsistent execution times, which might be flaky or worth investigating`,

            testMessagesInformation: `This graph presents the most frequently occurring fail/skip test messages:
- Bar: Displays messages ranked by number of occurrences represented as vertical bars.
- Timeline: Displays when those messages occurred to reveal noisy periods or problem spikes.
- The regular view shows the Top 10 most frequent messages; fullscreen mode expands this to the Top 50.
- To generalize messages (e.g., group similar messages), use the -m/--messageconfig option in the CLI (--help or README).`,

            testMostFlakyInformation: `This graph identifies the flakiest tests based on status flips (passed/failed/skipped):
- Bar: Displays tests ranked by frequency of status changes represented as vertical bars.
- Timeline: Displays when the status changes occurred across runs.
- The regular view shows the Top 10 flaky tests; fullscreen mode expands the list to the Top 50.
- "Ignore Skips" filters to only count passed/failed as status flips and not skips.`,

            testRecentMostFlakyInformation: `This graph identifies the most recently flaky tests based on status flips:
- Bar: Displays tests ranked by frequency of recent status changes represented as vertical bars.
- Timeline: Displays when the status changes occurred across runs.
- The most recent flaky tests are listed first.
- The regular view shows the Top 10; fullscreen mode expands the list to the Top 50.
- "Ignore Skips" filters to only count passed/failed as status flips and not skips.`,

            testMostFailedInformation: `This graph lists the most failed tests overall:
- Bar: Displays tests ranked by total number of failures represented as vertical bars.
- Timeline: Displays when failures occurred across runs.
- The regular view shows the Top 10 most failed tests; fullscreen mode expands the list to the Top 50.`,

            testRecentMostFailedInformation: `This graph lists the most recently failed tests:
- Bar: Displays tests ranked by number of recent failures represented as vertical bars.
- Timeline: Displays when failures occurred across runs.
- The most recently failed tests are listed first.
- The regular view shows the Top 10; fullscreen mode expands the list to the Top 50.`,

            keywordStatisticsInformation: `This graph presents keyword execution results in multiple formats:
- Percentages: Displays the distribution of passed/failed/skipped statuses for each keyword per run.
- Amount: Displays raw counts of each status per run.
- Line: Displays the same data but over a time axis.`,

            keywordTimesRunInformation: `This graph shows how frequently each keyword was executed:
- Bar: Displays times run per keyword represented as vertical bars.
- Line: Displays the same data but over a time axis.`,

            keywordTotalDurationInformation: `This graph visualizes total execution time of keywords:
- Bar: Displays the cumulative time each keyword ran during each run represented as vertical bars.
- Line: Displays the same data but over a time axis.`,

            keywordAverageDurationInformation: `This graph shows the average execution time per keyword:
- Bar: Displays the average duration for each keyword represented as vertical bars.
- Line: Displays the same data but over a time axis.`,

            keywordMinDurationInformation: `This graph shows the fastest observed execution time for each keyword per run:
- Bar: Displays minimum durations represented as vertical bars.
- Line: Displays the same data but over a time axis.`,

            keywordMaxDurationInformation: `This graph shows the slowest observed execution time for each keyword per run:
- Bar: Displays maximum durations represented as vertical bars.
- Line: Displays the same data but over a time axis.`,

            keywordMostFailedInformation: `This graph lists the most failed keywords overall:
- Bar: Displays keywords ranked by total number of failures represented as vertical bars.
- Timeline: Displays when failures occurred across runs.
- The regular view shows the Top 10 most failed keywords; fullscreen mode expands the list to the Top 50.`,

        };

        // colors
        const passedBackgroundBorderColor = "#97bd61";
        const passedBackgroundColor = "rgba(151, 189, 97, 0.7)";
        const skippedBackgroundBorderColor = "#fed84f";
        const skippedBackgroundColor = "rgba(254, 216, 79, 0.7)";
        const failedBackgroundBorderColor = "#ce3e01";
        const failedBackgroundColor = "rgba(206, 62, 1, 0.7)";
        const greyBackgroundBorderColor = "#0f172a";
        const greyBackgroundColor = "rgba(33, 37, 41, 0.7)";
        const graphFontSize = 12;

        // base bar config
        const barConfig = {
            borderSkipped: false,
            borderRadius: {
                topLeft: 8,
                topRight: 8,
                bottomLeft: 8,
                bottomRight: 8,
            },
        }
        const passedConfig = {
            backgroundColor: passedBackgroundColor,
            borderColor: passedBackgroundBorderColor,
            ...barConfig,
        }
        const failedConfig = {
            backgroundColor: failedBackgroundColor,
            borderColor: failedBackgroundBorderColor,
            ...barConfig,
        }
        const skippedConfig = {
            backgroundColor: skippedBackgroundColor,
            borderColor: skippedBackgroundBorderColor,
            ...barConfig,
        }
        // base line config
        const lineConfig = {
            tension: 0.1,
            pointRadius: 4,
            pointHoverRadius: 6
        }
        // data label background rectangle config
        const dataLabelConfig = {
            color: "#eee",
            backgroundColor: function (context) {
                return "rgba(0, 0, 0, 0.6)";
            },
            borderRadius: 4,
            padding: 3,
            align: "center",
            anchor: "center",
            font: {
                size: graphFontSize,
            },
        }

        // prepare input data
        const runs = decode_and_decompress("placeholder_runs").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        const suites = decode_and_decompress("placeholder_suites").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        const tests = decode_and_decompress("placeholder_tests").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        const keywords = decode_and_decompress("placeholder_keywords").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());

        function decode_and_decompress(base64Str) {
            const compressedData = Uint8Array.from(atob(base64Str), c => c.charCodeAt(0));
            const decompressedData = pako.inflate(compressedData, { to: 'string' });
            return JSON.parse(decompressedData);
        }

        var message_config = '"placeholder_message_config"'
        var filteredAmount = "placeholder_amount"
        var filteredAmountDefault = 0
        const use_logs = "placeholder_use_logs"
        const server = "placeholder_server"
        if (!message_config.includes("placeholder_message_config")) { message_config = JSON.parse(message_config) }

        // create graphs
        var runStatisticsGraph;
        var runDonutGraph;
        var runDonutTotalGraph;
        var runDurationGraph;
        var runHeatmapGraph;
        var runTable;
        var suiteFolderDonutGraph;
        var suiteFolderFailDonutGraph;
        var suiteStatisticsGraph;
        var suiteDurationGraph;
        var suiteMostFailedGraph;
        var suiteTable;
        var testStatisticsGraph;
        var testDurationGraph;
        var testDurationDeviationGraph;
        var testMessagesGraph
        var testMostFlakyGraph;
        var testRecentMostFlakyGraph;
        var testMostFailedGraph;
        var testRecentMostFailedGraph;
        var testTable;
        var keywordStatisticsGraph;
        var keywordTimesRunGraph;
        var keywordTotalDurationGraph;
        var keywordAverageDurationGraph;
        var keywordMinDurationGraph;
        var keywordMaxDurationGraph;
        var keywordMostFailedGraph;
        var keywordTable;

        // filtered data vars
        var filteredRuns;
        var filteredSuites;
        var filteredTests;
        var filteredKeywords;

        // var to keep track of the checkbox statuses
        var useSuitePathsSuiteSection = false;
        var useSuitePathsTestSection = false;
        var ignoreSkips = false; // test most flaky graph
        var ignoreSkipsRecent = false; // test recent most flaky graph
        var onlyFailedFolders = false; // suite folder donut
        var showingRunTags = false; // used to keep track if the runtags popup is showing and determine if it should be closed when clicked outside
        var inFullscreen = false; // used to keep track if fullscreen view is being shown
        var showDateLabels = true; // used to keep track of global date/run_start label setting
        var showLegends = true; // used to keep track of global legend setting
        var showAliases = false; // used to keep track of global alias setting
        var showMilliseconds = false; // used to keep track of global millisecond setting
        var heatMapHourAll = true; // used to keep track of the heatmap setting, is it set to an hour or all
        var previousFolder = ""; // used to update the suite folder donut to the previous folder with the button
        var lastScrollY = 0; // used to scroll back to where you were previously
        var maxGraphsPerRow = 2; // used to determine how many graphs to show per row

        // add items in hide modal
        const hideSections = [
            "Run Statistics",
            "Suite Statistics",
            "Test Statistics",
            "Keyword Statistics",
        ]
        const hideGraphs = [
            "Run Statistics",
            "Run Donut",
            "Run Stats",
            "Run Duration",
            "Run Heatmap",
            "Run Table",
            "Suite Folder Donut",
            "Suite Statistics",
            "Suite Duration",
            "Suite Most Failed",
            "Suite Table",
            "Test Statistics",
            "Test Duration",
            "Test Duration Deviation",
            "Test Messages",
            "Test Most Flaky",
            "Test Recent Most Flaky",
            "Test Most Failed",
            "Test Recent Most Failed",
            "Test Table",
            "Keyword Statistics",
            "Keyword Times Run",
            "Keyword Total Duration",
            "Keyword Average Duration",
            "Keyword Min Duration",
            "Keyword Max Duration",
            "Keyword Most Failed",
            "Keyword Table"
        ]
        var hideItem = `<li class="hideItem list-group-item list-group-item-action d-flex {type}">
            <div class="hideItemText">{value}</div>
            <button class="btn btn-sm moveUp"></button>
            <button class="btn btn-sm moveDown"></button>
            </li>`

        /////////////////////////////
        // GENERIC SETUP FUNCTIONS //
        /////////////////////////////

        // function to update the theme when the button is clicked
        function toggle_theme() {
            if (document.documentElement.classList.contains("dark-mode")) {
                localStorage.setItem("theme", "light");
            } else {
                localStorage.setItem("theme", "dark");
            }
            setup_theme()
            setup_all_graphs()
        }

        // theme function based on browser/machine color scheme
        function setup_theme() {
            Chart.defaults.font.size = graphFontSize
            function set_light_mode() {
                // bootstrap dark-mode attribute
                document.getElementsByTagName("html")[0].setAttribute("data-bs-theme", "light");
                // bootstrap default color
                document.documentElement.style.setProperty("--bs-body-bg", "#fff");
                // bootstrap buttons light -> dark
                const buttonsOutlineLight = document.querySelectorAll(".btn-outline-light")
                const buttonsLight = document.querySelectorAll(".btn-light")
                for (const button of buttonsOutlineLight) {
                    button.classList.remove("btn-outline-light");
                    button.classList.add("btn-outline-dark");
                }
                for (const button of buttonsLight) {
                    button.classList.remove("btn-light");
                    button.classList.add("btn-dark");
                }
                // chartjs default graph settings
                Chart.defaults.color = "#666";
                Chart.defaults.borderColor = "rgba(0,0,0,0.1)";
                Chart.defaults.backgroundColor = "rgba(0,0,0,0.1)";
                Chart.defaults.elements.line.borderColor = "rgba(0,0,0,0.1)";
                // set toggle in correct state if not already, needed on first load to set based on media or localstorage
                if (document.getElementById("toggleTheme").checked) {
                    document.getElementById("toggleTheme").checked = false
                }
            }

            function set_dark_mode() {
                // bootstrap dark-mode attribute
                document.getElementsByTagName("html")[0].setAttribute("data-bs-theme", "dark");
                // bootstrap light buttons -> dark
                document.documentElement.style.setProperty("--bs-body-bg", "rgba(30, 41, 59, 0.9)");
                // bootstrap buttons dark -> light
                const buttonsOutlineLight = document.querySelectorAll(".btn-outline-dark")
                const buttonsLight = document.querySelectorAll(".btn-dark")
                for (const button of buttonsOutlineLight) {
                    button.classList.remove("btn-outline-dark");
                    button.classList.add("btn-outline-light");
                }
                for (const button of buttonsLight) {
                    button.classList.remove("btn-dark");
                    button.classList.add("btn-light");
                }
                // chartjs default graph settings
                Chart.defaults.color = "#eee";
                Chart.defaults.borderColor = "rgba(255,255,255,0.1)";
                Chart.defaults.backgroundColor = "rgba(255,255,0,0.1)";
                Chart.defaults.elements.line.borderColor = "rgba(255,255,0,0.4)";
                if (!document.getElementById("toggleTheme").checked) {
                    document.getElementById("toggleTheme").checked = true
                }
            }

            const theme = localStorage.getItem("theme");
            const root = document.documentElement;
            const isDark = root.classList.contains("dark-mode");
            if (theme === "light") {
                if (isDark) root.classList.remove("dark-mode");
                set_light_mode();
            } else if (theme === "dark") {
                if (!isDark) root.classList.add("dark-mode");
                set_dark_mode();
            } else {
                // No theme in localStorage, fall back to system preference
                if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                    root.classList.add("dark-mode");
                    set_dark_mode();
                } else {
                    root.classList.remove("dark-mode");
                    set_light_mode();
                }
            }
        }

        // set default values
        function setup_stats() {
            document.getElementById("stats").innerHTML = `<i><a id="version" href="https://github.com/timdegroot1996/robotframework-dashboard" target="_blank">"placeholder_version"</a></i><br>
            <b>Database Summary</b><br>
            Runs: ${runs.length}<br>
            Suites: ${suites.length}<br>
            Tests: ${tests.length}<br>
            Keywords: ${keywords.length}`;

            filteredAmountDefault = filteredAmount
            document.getElementById("amount").value = filteredAmount
            if (server) {
                document.getElementById("openDashboard").hidden = false
            }
        }

        // function to update the filter row when scrolling
        function setup_scroll_eventlistener() {
            var scrollTimer, lastScrollFireTime = 0;
            window.addEventListener("scroll", function (event) {
                var minScrollTime = 200;
                var now = new Date().getTime();

                function process_scroll() {
                    var scroll = this.scrollY;
                    if (scroll > 100) {
                        document.getElementById("stats").hidden = true
                        document.getElementById("runsLabel").hidden = true
                        document.getElementById("runTagLabel").hidden = true
                        document.getElementById("fromDateLabel").hidden = true
                        document.getElementById("fromTimeLabel").hidden = true
                        document.getElementById("toDateLabel").hidden = true
                        document.getElementById("toTimeLabel").hidden = true
                        document.getElementById("amountLabel").hidden = true
                        document.getElementById("filterRowPadding").classList.add("pb-2")
                    } else {
                        document.getElementById("stats").hidden = false
                        document.getElementById("stats").hidden = false
                        document.getElementById("runsLabel").hidden = false
                        document.getElementById("runTagLabel").hidden = false
                        document.getElementById("fromDateLabel").hidden = false
                        document.getElementById("fromTimeLabel").hidden = false
                        document.getElementById("toDateLabel").hidden = false
                        document.getElementById("toTimeLabel").hidden = false
                        document.getElementById("amountLabel").hidden = false
                        document.getElementById("filterRowPadding").classList.remove("pb-2")
                    }
                }

                if (!scrollTimer) {
                    if (now - lastScrollFireTime > (3 * minScrollTime)) {
                        process_scroll();   // fire immediately on first scroll
                        lastScrollFireTime = now;
                    }
                    scrollTimer = setTimeout(function () {
                        scrollTimer = null;
                        lastScrollFireTime = new Date().getTime();
                        process_scroll();
                    }, minScrollTime);
                }
            });
        }

        // function to setup all collapse buttons and icons
        function setup_collapsables() {
            // initialize all collapsables by adding the eventlisteners to the buttons
            const collapsables = document.querySelectorAll(".collapse-icon")
            for (let collapsable of collapsables) {
                update_collapse_button(collapsable);
                collapsable.addEventListener("click", (e) => {
                    update_collapse_button(collapsable);
                });
            }
            // function that handles the setting of the correct icon when expanding/collapsing sections
            function update_collapse_button(element) {
                if (element.className.includes("collapsed")) {
                    if (element.id.includes("Details")) {
                        element.innerHTML = arrowRight;
                    } else {
                        element.innerHTML = arrowRightSmall;
                    }
                } else {
                    if (element.id.includes("Details")) {
                        element.innerHTML = arrowDown;
                    } else {
                        element.innerHTML = arrowDownSmall;
                    }
                }
            }
        }

        // function to update the section (menu) buttons with the correct eventlisteners
        // also sets up the automatic highlighting of the section that is most visible in the top
        // 20-50% percent of the screen
        function setup_section_buttons() {
            const sectionButtons = document.querySelectorAll("#sectionIndicator .btn");
            const sectionMap = {
                runStatisticsSection: sectionButtons[0],
                suiteStatisticsSection: sectionButtons[1],
                testStatisticsSection: sectionButtons[2],
                keywordStatisticsSection: sectionButtons[3]
            };

            sectionButtons.forEach(btn => btn.hidden = false); // unhide all
            const sectionHide = JSON.parse(localStorage.getItem("sectionHide")); // get hidden sections
            sectionHide.forEach(hiddenSection => sectionMap[`${space_to_camelcase(hiddenSection)}Section`].hidden = true) // hide section menu buttons that should be hidden

            const sections = Object.keys(sectionMap).map(id => document.getElementById(id));
            function update_active_section() {
                const viewportHeight = window.innerHeight;
                const viewportTop = viewportHeight * 0.2;
                const viewportBottom = viewportHeight * 0.5;
                let bestMatch = null;
                let bestMatchAmount = 0;
                sections.forEach(section => {
                    if (!section) return; // safety check
                    const rect = section.getBoundingClientRect();
                    // Calculate overlap in the 20%-50% viewport vertical range
                    const top = Math.max(rect.top, viewportTop);
                    const bottom = Math.min(rect.bottom, viewportBottom);
                    const overlap = bottom - top;
                    if (overlap > bestMatchAmount) {
                        bestMatch = section;
                        bestMatchAmount = overlap;
                    }
                });

                // Highlight the matching button
                sectionButtons.forEach(btn => btn.classList.remove("active"));
                if (bestMatch && sectionMap[bestMatch.id]) {
                    sectionMap[bestMatch.id].classList.add("active");
                }
            }

            window.addEventListener("scroll", update_active_section);
            // Initial call to set active on load
            update_active_section();

            sectionButtons.forEach(btn => {
                btn.addEventListener("click", () => {
                    const target = document.getElementById(btn.dataset.target);
                    if (target) {
                        const stickyTop = document.getElementById("filterSection");
                        const stickyHeight = stickyTop ? stickyTop.offsetHeight : 0;
                        const targetTop = target.getBoundingClientRect().top + window.pageYOffset;
                        const top = targetTop < 200 ? 0 : targetTop - stickyHeight - 8; // exception for the section at the top, scroll to 0
                        window.scrollTo({
                            top: top,
                            behavior: "auto"
                        });
                    }
                });
            });
        }

        // function to fill the information icons with the correct data
        function setup_information_icons() {
            const informationButtons = document.querySelectorAll(".information")
            for (let button of informationButtons) {
                button.innerHTML = informationSVG;
                const id = button.id;
                const title = informationTitles[id];
                button.setAttribute('data-title', title)
            }
        }

        // function to add a spinner for slow loads
        function setup_spinner(hide) {
            if (hide) {
                $("#loading").fadeOut(100)
                $("#runStatisticsSection").fadeIn()
                $("#suiteStatisticsSection").fadeIn()
                $("#testStatisticsSection").fadeIn()
                $("#keywordStatisticsSection").fadeIn()
            } else {
                $("#runStatisticsSection").hide()
                $("#suiteStatisticsSection").hide()
                $("#testStatisticsSection").hide()
                $("#keywordStatisticsSection").hide()
                $("#loading").show();
            }
        }

        // function to convert to camelcase
        function space_to_camelcase(string) {
            return string.replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
                return index === 0 ? word.toLowerCase() : word.toUpperCase();
            }).replace(/\s+/g, "");
        }

        // function to convert to camelcase from underscores
        function underscore_to_camelcase(str) {
            return str.replace(/_(.)/g, (match, group) => group.toUpperCase());
        }

        // function to convert camelcose to underscores
        function camelcase_to_underscore(str) {
            return str
                .replace(/([A-Z]+)/g, "_$1")     // Prefix all capital groups with _
                .replace(/^_/, "")               // Remove leading underscore if it appears
                .toLowerCase();                  // Convert everything to lowercase
        }

        // function to convert a date object to the desired string format
        function format_date_to_string(date) {
            const pad = (n) => n.toString().padStart(2, "0");
            const year = date.getFullYear();
            const month = pad(date.getMonth() + 1); // Months are 0-indexed
            const day = pad(date.getDate());
            const hours = pad(date.getHours());
            const minutes = pad(date.getMinutes());
            const seconds = pad(date.getSeconds());
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // function to transform an output.xml path to a log.html path
        function transform_file_path(filePath) {
            const normalizedPath = filePath.replace(/\\/g, "/");
            const pathSegments = normalizedPath.split("/");
            const filename = pathSegments.pop();
            const updatedFilename = filename.replace(/output/g, "log").replace(/\.xml$/i, ".html");
            const updatedPath = [...pathSegments, updatedFilename].join("/");
            return filePath.includes("\\") ? updatedPath.replace(/\//g, "\\") : updatedPath;
        }

        // function used to combine paths to open the correct log file, used in combination with a file server
        function combine_paths(baseUrlStr, relativePath) {
            const baseUrl = new URL(baseUrlStr);
            const baseParts = baseUrl.pathname.split("/").filter(Boolean);
            const relParts = relativePath.replaceAll("\\", "/").split("/").filter(Boolean);
            // Find the first matching folder name from the relative path in the base path
            let match = null;
            for (let i = 0; i < relParts.length; i++) {
                const folder = relParts[i];
                const baseMatchIndex = baseParts.lastIndexOf(folder);
                if (baseMatchIndex !== -1) {
                    match = { baseIndex: baseMatchIndex, relIndex: i };
                    break;
                }
            }

            let combinedParts;
            if (match) {
                const baseSlice = baseParts.slice(0, match.baseIndex);
                const relSlice = relParts.slice(match.relIndex);
                combinedParts = [...baseSlice, ...relSlice];
            } else {
                combinedParts = relParts;
            }

            // Resolve "." and ".."
            const resolvedParts = [];
            for (const part of combinedParts) {
                if (part === ".") continue;
                if (part === "..") {
                    if (resolvedParts.length > 0) resolvedParts.pop();
                } else {
                    resolvedParts.push(part);
                }
            }

            return baseUrl.origin + "/" + resolvedParts.join("/");
        }

        // function to update the localstorage and graphs for the suitepath switches
        function update_switch_local_storage(id, state, firstLoad = false) {
            const storageState = JSON.parse(localStorage.getItem(id));
            if (firstLoad) {
                if (storageState) {
                    window[id] = storageState;
                    document.getElementById(id).checked = true;
                }
            } else {
                localStorage.setItem(id, JSON.stringify(state));
            }
        }

        // function to get a higher folder path based on the full_path or partial full_path provided
        function get_next_folder_level(fullPath, currentPath) {
            const fullParts = fullPath.split(".");
            const currentParts = currentPath.split(".");
            if (
                currentParts.length < fullParts.length &&
                fullParts.slice(0, currentParts.length).join(".") === currentPath
            ) {
                return fullParts.slice(0, currentParts.length + 1).join(".");
            }
            return currentPath;
        }

        //////////////////////////////
        // CUSTOMIZE VIEW FUNCTIONS //
        //////////////////////////////

        // function to update the arrows in the customize modal
        function setup_customize_view_arrow_eventlisteners() {
            // function to move the items from showing to hidden
            function move_items(fromId, toId) {
                const fromBox = document.getElementById(fromId);
                const toBox = document.getElementById(toId);
                const selectedItems = fromBox.querySelectorAll(".active");
                const fromStorage = JSON.parse(localStorage.getItem(fromId));
                const toStorage = JSON.parse(localStorage.getItem(toId));

                for (let item of selectedItems) {
                    const val = item.children[0].innerText;
                    if (toId.includes("Hide")) {
                        if (!toStorage.includes(val)) toStorage.push(val);
                        const identifier = val.split(" ")[0];
                        if (toId.includes("section")) disable_graphs_in_customize_view(true, identifier);
                    } else {
                        const index = fromStorage.indexOf(val);
                        if (index !== -1) fromStorage.splice(index, 1);
                        const identifier = val.split(" ")[0];
                        if (toId.includes("section")) disable_graphs_in_customize_view(false, identifier);
                    }
                }
                localStorage.setItem(fromId, JSON.stringify(fromStorage));
                localStorage.setItem(toId, JSON.stringify(toStorage));
                selectedItems.forEach(item => {
                    item.classList.remove("active");
                    if (toId === "graphShow") {
                        const section = item.children[0].innerText.split(" ")[0];
                        const listItems = document.getElementById("graphShow").querySelectorAll(".hideItem");
                        let lastMatchingItem = Array.from(listItems).reverse().find(li => {
                            return li.children[0].innerText.startsWith(section);
                        }) || listItems[listItems.length - 1];
                        lastMatchingItem?.after(item);
                    } else {
                        toBox.appendChild(item);
                    }
                });
            }

            // Map the arrow actions and associated operations
            const arrowMappings = {
                "sectionRight": { from: "sectionShow", to: "sectionHide", content: arrowRight },
                "sectionLeft": { from: "sectionHide", to: "sectionShow", content: arrowLeft },
                "graphRight": { from: "graphShow", to: "graphHide", content: arrowRight },
                "graphLeft": { from: "graphHide", to: "graphShow", content: arrowLeft }
            };

            // Initialize arrows with their respective functionality and content
            for (let arrow in arrowMappings) {
                const { from, to, content } = arrowMappings[arrow];
                // Update button content based on direction
                update_arrow_button(arrow, content);
                // Add event listener to each arrow button
                document.getElementById(arrow).addEventListener("click", () => {
                    move_items(from, to);
                });
            }

            // Function to update arrow button content
            function update_arrow_button(id, content) {
                document.getElementById(id).innerHTML = content;
            }
        }

        // function to handle the setting of the localstorge for customized view
        function setup_customize_view_local_storage() {
            const adminDefaults = {
                sectionHide: "placeholder_admin_section_hide",
                sectionShow: "placeholder_admin_section_show",
                graphHide: "placeholder_admin_graph_hide",
                graphShow: "placeholder_admin_graph_show"
            };

            const keys = Object.keys(adminDefaults);

            // Helper: Convert legacy "'item1','item2'" string into array
            function migrate_legacy_string(value) {
                if (typeof value === "string") {
                    return value.split(",")
                        .map(v => v.trim().replace(/^'+|'+$/g, "")) // strip surrounding single quotes
                        .filter(v => v !== "");
                }
                return [];
            }

            // Handle migration or init of all keys
            keys.forEach(key => {
                let raw = localStorage.getItem(key);

                if (raw === null) {
                    // Not present at all → store empty array
                    localStorage.setItem(key, JSON.stringify([]));
                } else {
                    try {
                        // Try parsing as JSON array (new format)
                        const parsed = JSON.parse(raw);
                        if (!Array.isArray(parsed)) throw new Error("Not an array");
                    } catch (e) {
                        // Legacy format → migrate to array
                        const migrated = migrate_legacy_string(raw);
                        localStorage.setItem(key, JSON.stringify(migrated));
                    }
                }
            });

            // Apply admin defaults only if all are still empty arrays
            const allEmpty = keys.every(key => {
                const val = JSON.parse(localStorage.getItem(key));
                return Array.isArray(val) && val.length === 0;
            });

            // Actually set the defaults, either admin or normal
            if (allEmpty) {
                if (
                    !adminDefaults.sectionHide.includes("placeholder_admin") &&
                    (
                        adminDefaults.sectionShow.length > 0 ||
                        adminDefaults.graphShow.length > 0 ||
                        adminDefaults.sectionHide.length > 0 ||
                        adminDefaults.graphHide.length > 0
                    )
                ) {
                    // the admin defaults are set
                    keys.forEach(key => {
                        localStorage.setItem(key, JSON.stringify(adminDefaults[key]));
                    });
                } else {
                    // there is no admin defaults so use the regular defaults
                    localStorage.setItem("sectionShow", JSON.stringify(hideSections))
                    localStorage.setItem("graphShow", JSON.stringify(hideGraphs))
                }
            }

            // Graph type defaults (unchanged)
            const defaultGraphTypes = {
                runStatisticsGraphType: "percentages",
                runDonutGraphType: "donut",
                runDonutTotalGraphType: "donut",
                runStatsGraphType: "stats",
                runDurationGraphType: "line",
                runHeatmapGraphType: "heatmap",
                suiteFolderDonutGraphType: "donut",
                suiteStatisticsGraphType: "percentages",
                suiteDurationGraphType: "line",
                suiteMostFailedGraphType: "bar",
                testStatisticsGraphType: "timeline",
                testDurationGraphType: "line",
                testDurationDeviationGraphType: "bar",
                testMessagesGraphType: "timeline",
                testMostFlakyGraphType: "timeline",
                testRecentMostFlakyGraphType: "timeline",
                testMostFailedGraphType: "timeline",
                testRecentMostFailedGraphType: "timeline",
                keywordStatisticsGraphType: "percentages",
                keywordTimesRunGraphType: "bar",
                keywordTotalDurationGraphType: "line",
                keywordAverageDurationGraphType: "line",
                keywordMinDurationGraphType: "bar",
                keywordMaxDurationGraphType: "bar",
                keywordMostFailedGraphType: "timeline",
            };

            let storedTypes = localStorage.getItem("graphTypes");
            if (!storedTypes) {
                localStorage.setItem("graphTypes", JSON.stringify(defaultGraphTypes));
                storedTypes = defaultGraphTypes;
            } else {
                storedTypes = JSON.parse(storedTypes);
                // Below exception is created to handle problems when switching between old versions without graphs
                // to newer versions with additional graphs. The view is completely reset to add all graphs again.
                const storedKeys = Object.keys(storedTypes);
                const defaultKeys = Object.keys(defaultGraphTypes);
                const mismatch = storedKeys.length !== defaultKeys.length ||
                    defaultKeys.some(key => !(key in storedTypes));
                if (mismatch) {
                    for (const key in defaultGraphTypes) {
                        if (!(key in storedTypes)) {
                            storedTypes[key] = defaultGraphTypes[key];
                        }
                    }
                    localStorage.setItem("sectionHide", JSON.stringify([]));
                    localStorage.setItem("graphHide", JSON.stringify([]));
                    localStorage.setItem("sectionShow", JSON.stringify(hideSections));
                    localStorage.setItem("graphShow", JSON.stringify(hideGraphs));
                    localStorage.setItem("graphTypes", JSON.stringify(defaultGraphTypes));
                }
            }

            for (let key in storedTypes) {
                window[key] = storedTypes[key];
                update_button_selection(key.replace('GraphType', ""), storedTypes[key]);
            }
        }

        // function to update the localstorage of the graphtypes
        function update_graph_type(graph, type) {
            const storedTypes = JSON.parse(localStorage.getItem("graphTypes") || "{}");
            storedTypes[graph] = type;
            localStorage.setItem("graphTypes", JSON.stringify(storedTypes));
            // Also update global variable
            window[graph] = type;
        }

        // function to change which button is highlighted styling wise
        function update_button_selection(camelButtonName, graphType) {
            const buttons = ["Bar", "Line", "Timeline", "Percentages", "Amount", "Donut", "Stats", "Heatmap"]; // All possible button types
            buttons.forEach(button => {
                const buttonId = `${camelButtonName}Graph${button}`;
                if (document.getElementById(buttonId)) {
                    if (document.documentElement.classList.contains("dark-mode")) {
                        if (button.toLowerCase() === graphType) {
                            document.getElementById(buttonId).classList.add("active");
                            document.getElementById(buttonId).classList.remove("btn-outline-light");
                            document.getElementById(buttonId).classList.add("btn-outline-light");
                        } else {
                            document.getElementById(buttonId).classList.remove("active");
                            document.getElementById(buttonId).classList.remove("btn-outline-light");
                            document.getElementById(buttonId).classList.add("btn-outline-light");
                        }
                    } else {
                        if (button.toLowerCase() === graphType) {
                            document.getElementById(buttonId).classList.add("active");
                            document.getElementById(buttonId).classList.remove("btn-outline-dark");
                            document.getElementById(buttonId).classList.add("btn-outline-dark");
                        } else {
                            document.getElementById(buttonId).classList.remove("active");
                            document.getElementById(buttonId).classList.remove("btn-outline-dark");
                            document.getElementById(buttonId).classList.add("btn-outline-dark");
                        }
                    }
                }
            });
        }

        // create the modal with the correct layout based on localstorage
        function setup_customize_view_content() {
            const graphShow = JSON.parse(localStorage.getItem("graphShow"));
            const graphHide = JSON.parse(localStorage.getItem("graphHide"));
            const sectionShow = JSON.parse(localStorage.getItem("sectionShow"));
            const sectionHide = JSON.parse(localStorage.getItem("sectionHide"));

            let graphShowItems = "", graphHideItems = "";
            let sectionShowItems = "", sectionHideItems = "";

            for (let graph of [...graphShow, ...graphHide]) {
                const element = hideItem.replaceAll("{value}", graph).replaceAll("{type}", "graph");
                if (graphHide.includes(graph)) {
                    graphHideItems += element;
                } else {
                    graphShowItems += element;
                }
            }
            document.getElementById("graphShow").innerHTML = graphShowItems;
            document.getElementById("graphHide").innerHTML = graphHideItems;

            for (let section of [...sectionShow, ...sectionHide]) {
                const element = hideItem.replaceAll("{value}", section).replaceAll("{type}", "section");
                if (sectionHide.includes(section)) {
                    const identifier = section.split(" ")[0];
                    disable_graphs_in_customize_view(true, identifier);
                    sectionHideItems += element;
                } else {
                    sectionShowItems += element;
                }
            }
            document.getElementById("sectionShow").innerHTML = sectionShowItems;
            document.getElementById("sectionHide").innerHTML = sectionHideItems;

            document.querySelectorAll(".graph .moveUp, .section .moveUp").forEach(item => {
                item.innerHTML = arrowUpVerySmall;
                item.addEventListener("click", function (event) {
                    const before = $(this).parent().prev();
                    if (before.length) $(this).parent().insertBefore(before);
                    event.stopPropagation();
                });
            });

            document.querySelectorAll(".graph .moveDown, .section .moveDown").forEach(item => {
                item.innerHTML = arrowDownVerySmall;
                item.addEventListener("click", function (event) {
                    const after = $(this).parent().next();
                    if (after.length) $(this).parent().insertAfter(after);
                    event.stopPropagation();
                });
            });

            document.querySelectorAll(".hideItem").forEach(item => {
                item.addEventListener("click", function () {
                    this.classList.toggle("active");
                });
            });
        }

        // function to add/remove disabled to the graphs in the customize view popup
        function disable_graphs_in_customize_view(disable, identifier) {
            const relatedGraphs1 = document.getElementById("graphShow").querySelectorAll(".hideItemText")
            const relatedGraphs2 = document.getElementById("graphHide").querySelectorAll(".hideItemText")
            const relatedGraphs = [...relatedGraphs1, ...relatedGraphs2]
            for (const graph of relatedGraphs) {
                if (graph.innerText.startsWith(identifier)) {
                    if (disable) {
                        graph.parentElement.classList.add("disabled");
                    } else {
                        graph.parentElement.classList.remove("disabled");
                    }
                }
            }
        }

        // function to sync current order to localStorage
        function update_customize_view_local_storage() {
            const sectionOrder = Array.from(document.getElementById("sectionShow").querySelectorAll(".hideItem"))
                .map(item => item.children[0].innerText);
            const graphOrder = Array.from(document.getElementById("graphShow").querySelectorAll(".hideItem"))
                .map(item => item.children[0].innerText);
            localStorage.setItem("sectionShow", JSON.stringify(sectionOrder));
            localStorage.setItem("graphShow", JSON.stringify(graphOrder));
        }

        /////////////////////////////
        // EVENTLISTENER FUNCTIONS //
        /////////////////////////////

        // function to create customized view eventlisteners
        function setup_customize_view_button_eventlisteners() {
            // update the theme
            document.getElementById("toggleTheme").addEventListener("click", function () {
                toggle_theme()
            });

            // update all graphs to not have date labels
            function toggle_labels(load = false) {
                var storage = JSON.parse(localStorage.getItem("showDateLabels"));
                const toggle = document.getElementById("toggleLabels")
                if (!load) {
                    storage = !storage
                }
                if (storage === true) {
                    showDateLabels = true
                    toggle.checked = true
                } else if (storage === false) {
                    showDateLabels = false
                    toggle.checked = false
                } else {
                    toggle.checked = showDateLabels // first load and default value
                }
                localStorage.setItem("showDateLabels", JSON.stringify(showDateLabels));
                if (!load) { setup_data_and_graphs() }
            }
            toggle_labels(true) // run once on load to setup correctly
            document.getElementById("toggleLabels").addEventListener("click", function () {
                toggle_labels(false)
            });

            // helper function to update the legend setting where needed
            function toggle_legends(load = false) {
                var storage = JSON.parse(localStorage.getItem("showLegends"));
                const toggle = document.getElementById("toggleLegends")
                if (!load) {
                    storage = !storage
                }
                if (storage === true) {
                    showLegends = true
                    toggle.checked = true
                } else if (storage === false) {
                    showLegends = false
                    toggle.checked = false
                } else {
                    toggle.checked = showLegends // first load and default value
                }
                localStorage.setItem("showLegends", JSON.stringify(showLegends));
                if (!load) { setup_data_and_graphs() }
            }
            toggle_legends(true) // run once on load to setup correctly
            document.getElementById("toggleLegends").addEventListener("click", function () {
                toggle_legends(false)
            });

            // update all graphs to not use either aliases or run_starts
            function toggle_aliases(load = false) {
                var storage = JSON.parse(localStorage.getItem("showAliases"));
                const toggle = document.getElementById("toggleAliases")
                if (!load) {
                    storage = !storage
                }
                if (storage === true) {
                    showAliases = true
                    toggle.checked = true
                } else if (storage === false) {
                    showAliases = false
                    toggle.checked = false
                } else {
                    toggle.checked = showAliases // first load and default value
                }
                localStorage.setItem("showAliases", JSON.stringify(showAliases));
                if (!load) { setup_data_and_graphs() }
            }
            toggle_aliases(true) // run once on load to setup correctly
            document.getElementById("toggleAliases").addEventListener("click", function () {
                toggle_aliases(false)
            });

            // update all graphs to use run_starts with or without milliseconds
            function toggle_milliseconds(load = false) {
                var storage = JSON.parse(localStorage.getItem("showMilliseconds"));
                const toggle = document.getElementById("toggleMilliseconds")
                if (!load) {
                    storage = !storage
                }
                if (storage === true) {
                    showMilliseconds = true
                    toggle.checked = true
                } else if (storage === false) {
                    showMilliseconds = false
                    toggle.checked = false
                } else {
                    toggle.checked = showMilliseconds // first load and default value
                }
                localStorage.setItem("showMilliseconds", JSON.stringify(showMilliseconds));
                if (!load) { setup_data_and_graphs() }
            }
            toggle_milliseconds(true) // run once on load to setup correctly
            document.getElementById("toggleMilliseconds").addEventListener("click", function () {
                toggle_milliseconds(false)
            });

            // update the max graphs per row limit
            function toggle_graph_limit(load = false) {
                var storage = parseInt(JSON.parse(localStorage.getItem("maxGraphsPerRow")));
                const toggle = document.getElementById("toggleMaxGraphsPerRow")
                if (load) {
                    if (storage) { // update from storage if it exists
                        maxGraphsPerRow = storage
                    }
                    toggle.value = maxGraphsPerRow // on first load always set the toggle to the correct value
                } else { // not first load so the toggle changed, update value and storage accordingly
                    maxGraphsPerRow = toggle.value
                }
                localStorage.setItem("maxGraphsPerRow", JSON.stringify(maxGraphsPerRow));
                if (!load) { setup_data_and_graphs() }
            }
            toggle_graph_limit(true) // run once on load to setup correctly
            document.getElementById("toggleMaxGraphsPerRow").addEventListener("change", function () {
                toggle_graph_limit(false)
            });

            // update all graphs based on new hidden graphs/sections
            document.getElementById("saveSettings").addEventListener("click", function () {
                document.getElementById("runs").focus()
                update_customize_view_local_storage();
                setup_data_and_graphs();
            });

            // remove the entire customized view configuration
            document.getElementById("resetGraphConfig").addEventListener("click", function () {
                document.getElementById("runs").focus()
                localStorage.setItem("sectionHide", JSON.stringify([]));
                localStorage.setItem("graphHide", JSON.stringify([]));
                localStorage.setItem("sectionShow", JSON.stringify(hideSections));
                localStorage.setItem("graphShow", JSON.stringify(hideGraphs));
                setup_customize_view_content();
                update_customize_view_local_storage();
                setup_data_and_graphs();
            });
        }

        // function to setup eventlisteners for filter buttons
        function setup_eventlisteners_filter_buttons() {
            // eventlisteners for filters (runTags is done separately because of different usage)
            const filters = ["runs", "fromDate", "fromTime", "toDate", "toTime", "amount"]
            for (let f of filters) {
                document.getElementById(f).addEventListener("change", setup_data_and_graphs);
            }

            // has to be added after the creation of the secctions and graphs
            document.getElementById("suiteFolderDonutGoUp").addEventListener("click", function () {
                function remove_last_folder(path) {
                    const parts = path.split(".");
                    parts.pop();
                    return parts.length > 0 ? parts.join('.') : "";
                }
                const folder = remove_last_folder(previousFolder)
                if (previousFolder == "" && folder == "") { return }
                create_suite_folder_donut_graph(folder)
            });

            // eventlisteners for fullscreen buttons
            const fullscreenButtons = ["runStatistics", "runDonut", "runStats", "runDuration", "runHeatmap",
                "suiteFolderDonut", "suiteStatistics", "suiteDuration", "suiteMostFailed", "testStatistics",
                "testDuration", "testDurationDeviation", "testMessages", "testMostFlaky", "testRecentMostFlaky",
                "testMostFailed", "testRecentMostFailed", "keywordStatistics", "keywordTimesRun", "keywordTotalDuration",
                "keywordAverageDuration", "keywordMinDuration", "keywordMaxDuration", "keywordMostFailed"]
            for (let fullscreenButton of fullscreenButtons) {
                document.getElementById(`${fullscreenButton}Fullscreen`).addEventListener("click", (e) => {
                    lastScrollY = window.scrollY
                    inFullscreen = !inFullscreen;
                    $("#filterSection").hide();
                    document.getElementById(`${fullscreenButton}Canvas`).classList.add("fullscreen");
                    document.getElementById(`${fullscreenButton}Close`).hidden = false;
                    document.getElementById(`${fullscreenButton}Fullscreen`).hidden = true;
                    document.body.classList.add("lock-scroll");
                    window[`create_${camelcase_to_underscore(fullscreenButton)}_graph`]();
                    if (fullscreenButton == "runDonut") {
                        create_run_donut_total_graph();
                    }
                    if (fullscreenButton == "suiteFolderDonut") {
                        create_suite_folder_fail_donut_graph();
                    }
                });
                document.getElementById(`${fullscreenButton}Close`).addEventListener("click", (e) => {
                    inFullscreen = !inFullscreen;
                    $("#filterSection").show();
                    document.getElementById(`${fullscreenButton}Canvas`).classList.remove("fullscreen");
                    document.getElementById(`${fullscreenButton}Close`).hidden = true;
                    document.getElementById(`${fullscreenButton}Fullscreen`).hidden = false;
                    document.body.classList.remove("lock-scroll");
                    window[`create_${camelcase_to_underscore(fullscreenButton)}_graph`]();
                    if (fullscreenButton == "runDonut") {
                        create_run_donut_total_graph();
                    }
                    if (fullscreenButton == "suiteFolderDonut") {
                        create_suite_folder_fail_donut_graph();
                    }
                    window.scrollTo({
                        top: lastScrollY,
                        behavior: "auto"
                    });
                });
            }
        }

        // function to setup eventlisteners for changing the graph view buttons
        function setup_eventlisteners_graph_view_buttons() {
            // ignore skip button eventlisteners
            document.getElementById("ignoreSkips").addEventListener("change", (e) => {
                ignoreSkips = !ignoreSkips;
                create_test_most_flaky_graph();
            });
            document.getElementById("ignoreSkipsRecent").addEventListener("change", (e) => {
                ignoreSkipsRecent = !ignoreSkipsRecent;
                create_test_recent_most_flaky_graph();
            });
            document.getElementById("onlyFailedFolders").addEventListener("change", (e) => {
                onlyFailedFolders = !onlyFailedFolders;
                create_suite_folder_donut_graph("");
            });
            document.getElementById("heatMapTestType").addEventListener("change", (e) => {
                create_run_heatmap_graph();
            });
            document.getElementById("heatMapHour").addEventListener("change", (e) => {
                heatMapHourAll = document.getElementById("heatMapHour").value == "All" ? true : false;
                create_run_heatmap_graph();
            });
            // eventlisteners for buttons to change graph views
            const graphChangeButtons = {
                "run_statistics": "Percentages,Line,Amount",
                "run_donut": "Donut",
                "run_stats": "Stats",
                "run_duration": "Bar,Line",
                "run_heatmap": "Heatmap",
                "suite_folder_donut": "Donut",
                "suite_statistics": "Percentages,Line,Amount",
                "suite_duration": "Bar,Line",
                "suite_most_failed": "Bar,Timeline",
                "test_duration": "Bar,Line",
                "test_duration_deviation": "Bar",
                "test_messages": "Bar,Timeline",
                "test_most_flaky": "Bar,Timeline",
                "test_recent_most_flaky": "Bar,Timeline",
                "test_most_failed": "Bar,Timeline",
                "test_recent_most_failed": "Bar,Timeline",
                "keyword_statistics": "Percentages,Line,Amount",
                "keyword_times_run": "Bar,Line",
                "keyword_total_duration": "Bar,Line",
                "keyword_average_duration": "Bar,Line",
                "keyword_min_duration": "Bar,Line",
                "keyword_max_duration": "Bar,Line",
                "keyword_most_failed": "Bar,Timeline"
            };

            function handle_graph_change_type_button_click(graphChangeButton, graphType, camelButtonName) {
                // Dynamically trigger the graph creation function
                update_graph_type(`${camelButtonName}GraphType`, graphType)
                window[`create_${graphChangeButton}_graph`]();
                if (graphChangeButton == 'run_donut') { create_run_donut_total_graph(); }
                if (graphChangeButton == 'suite_folder_donut') { create_suite_folder_fail_donut_graph(); }
                // Update the UI to enable/disable buttons accordingly
                update_button_selection(camelButtonName, graphType)
            }

            function add_graph_eventlisteners(graphChangeButton, buttonTypes) {
                const camelButtonName = underscore_to_camelcase(graphChangeButton);
                const graphTypes = buttonTypes.split(",");
                graphTypes.forEach((graphType, index) => {
                    const buttonId = `${camelButtonName}Graph${graphType}`;
                    if (document.getElementById(buttonId)) {
                        document.getElementById(buttonId).addEventListener("click", (e) => {
                            handle_graph_change_type_button_click(graphChangeButton, graphType.toLowerCase(), camelButtonName);
                        });
                    }
                });
            }

            // Iterate over the graphChangeButtons object to attach event listeners
            Object.entries(graphChangeButtons).forEach(([graphChangeButton, buttonTypes]) => {
                add_graph_eventlisteners(graphChangeButton, buttonTypes);
            });
        }

        // function to handle the eventlisteners for all filter options in the sections
        function setup_eventlisteners_section_filter_buttons() {
            // function to keep track of the checkboxes for the runtags
            function show_checkboxes() {
                const checkboxes = document.getElementById("checkboxes");
                showingRunTags = !showingRunTags;
                checkboxes.style.display = showingRunTags ? "block" : "none";
            }
            document.getElementById("selectRunTags").addEventListener("click", show_checkboxes);
            document.getElementById("resetFilters").addEventListener("click", function () {
                document.getElementById("runs").value = "All";
                document.getElementById("runTag").value = "All";
                document.getElementById("amount").value = filteredAmountDefault;
                setup_lowest_highest_dates(runs);
                setup_data_and_graphs();
            });
            document.getElementById("suiteSelectSuites").addEventListener("change", (e) => {
                create_suite_duration_graph();
                create_suite_statistics_graph();
            });
            document.getElementById("useSuitePathsSuiteSection").addEventListener("change", (e) => {
                useSuitePathsSuiteSection = !useSuitePathsSuiteSection;
                update_switch_local_storage("useSuitePathsSuiteSection", useSuitePathsSuiteSection);
                setup_suites_in_suite_select();
                create_suite_statistics_graph();
                create_suite_duration_graph();
                create_suite_most_failed_graph();
            });
            // update the local storage for the suite path buttons on first load
            update_switch_local_storage("useSuitePathsSuiteSection", useSuitePathsSuiteSection, true);
            document.getElementById("resetSuiteFolder").addEventListener("click", (e) => {
                create_suite_folder_donut_graph("");
            });
            document.getElementById("suiteSelectTests").addEventListener("change", (e) => {
                setup_testtags_in_select();
                setup_tests_in_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("useSuitePathsTestSection").addEventListener("change", (e) => {
                useSuitePathsTestSection = !useSuitePathsTestSection;
                update_switch_local_storage("useSuitePathsTestSection", useSuitePathsTestSection);
                setup_suites_in_test_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
                create_test_messages_graph();
                create_test_most_flaky_graph();
                create_test_recent_most_flaky_graph();
                create_test_most_failed_graph();
                create_test_recent_most_failed_graph();
            });
            // update the local storage for the suite path buttons on first load
            update_switch_local_storage("useSuitePathsTestSection", useSuitePathsTestSection, true);
            document.getElementById("testTagsSelect").addEventListener("change", (e) => {
                setup_tests_in_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("testSelect").addEventListener("change", (e) => {
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("keywordSelect").addEventListener("change", (e) => {
                create_keyword_statistics_graph();
                create_keyword_times_run_graph();
                create_keyword_total_duration_graph();
                create_keyword_average_duration_graph();
                create_keyword_min_duration_graph();
                create_keyword_max_duration_graph();
            });
            const checkboxesElement = document.getElementById("checkboxes");
            const runTagsSelectElement = document.getElementById("selectRunTags");
            // listen for click events on body to hide the run checkboxes when clicking outside of the select/checkboxes elements
            document.body.addEventListener("click", function (event) {
                if (showingRunTags == true && !checkboxesElement.contains(event.target) && !runTagsSelectElement.contains(event.target)) {
                    show_checkboxes()
                }
            });
        }

        /////////////////////////////////////
        // FILTER BUTTON CONTENT FUNCTIONS //
        /////////////////////////////////////

        // function to setup run amount filter maximum
        function setup_run_amount_filter() {
            document.getElementById("amount").setAttribute("max", runs.length)
        }

        // function that initializes the from date/time and to date/time selection boxes in the filters
        function setup_lowest_highest_dates() {
            var dates = [];
            for (run of runs) {
                dates.push(new Date(run.run_start));
            }
            if (dates.length == 0) {
                document.getElementById("fromDate").value = "1900-01-01";
                document.getElementById("fromTime").value = "00:00";
                document.getElementById("toDate").value = "9999-12-31";
                document.getElementById("toTime").value = "23:59";
                return
            }
            var lowest = new Date(Math.min.apply(null, dates));
            var highest = new Date(Math.max.apply(null, dates));
            var tzoffset = new Date().getTimezoneOffset() * 60000;
            lowest = new Date(new Date(lowest - tzoffset).getTime() + -1 * 60000); // this is to account for seconds in the initial filter value
            highest = new Date(new Date(highest - tzoffset).getTime() + 1 * 60000); // this is to account for seconds in the initial filter value
            lowest.setTime(lowest.getTime() - 1 * 60 * 60 * 1000) // minus 1 hour to account for possible daylight saving time switches of 1 hour!
            highest.setTime(highest.getTime() + 1 * 60 * 60 * 1000) // plus 1 hour to account for possible daylight saving time switches of 1 hour!
            document.getElementById("fromDate").value = lowest.toISOString().split("T")[0];
            document.getElementById("fromTime").value = lowest.toISOString().split("T")[1].substring(0, 5);
            document.getElementById("toDate").value = highest.toISOString().split("T")[0];
            document.getElementById("toTime").value = highest.toISOString().split("T")[1].substring(0, 5);
        }

        // function to update the available runs to select in the filters
        function setup_runs_in_select_filter_buttons() {
            const runOptions = new Set();
            runs.forEach(run => runOptions.add(run.name));
            const optionsHtml = Array.from(runOptions)
                .map(runName => `<option value="${runName}">${runName}</option>`)
                .join("");
            const runsSelect = document.getElementById("runs");
            runsSelect.innerHTML = `<option value="All">All</option>` + optionsHtml;
        }

        // function to update the available runtags to select in the filters
        function setup_runtags_in_select_filter_buttons() {
            const tags = new Set();
            runs.forEach(run => {
                run.tags.split(",").forEach(tag => {
                    if (tag) { // Avoid adding empty tags
                        tags.add(tag);
                    }
                });
            });
            const andOrTags = `
                <li class="list-group-item d-flex small" onclick="setup_data_and_graphs()">
                    <div class="btn-group form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="useOrTags" />
                    </div>
                    <div class="btn-group">
                        <label class="form-check-label" for="useOrTags">Use OR (default AND)</label>
                    </div>
                </li>
            `;
            const listItemTemplate = (value) => `
                <li class="list-group-item list-group-item-action d-flex small" onclick="setup_data_and_graphs()">
                    <input class="form-check-input me-1" type="checkbox" value="" id="${value}">
                    <label class="form-check-label ms-2" for="${value}">${value}</label>
                </li>
            `;
            const listItems = [listItemTemplate("All")].concat(
                Array.from(tags).map(tag => listItemTemplate(tag))
            ).join("");
            const tagsSelect = document.getElementById("runTag");
            tagsSelect.innerHTML = andOrTags + listItems;
            document.getElementById("All").checked = true;

        }

        // function to update the available suites to select in the suite filters
        function setup_suites_in_suite_select() {
            const suiteSelectSuites = document.getElementById("suiteSelectSuites");
            const suiteFolder = document.getElementById("suiteFolder").innerText;
            suiteSelectSuites.innerHTML = "";
            var suiteNames = new Set()
            for (const suite of filteredSuites) {
                if (suiteFolder != "All" && !(suite.full_name.startsWith(suiteFolder + ".") || suite.full_name == suiteFolder)) {
                    continue
                }
                if (useSuitePathsSuiteSection) {
                    suiteNames.add(suite.full_name);
                } else {
                    suiteNames.add(suite.name);
                }
            }
            suiteNames = [...suiteNames].sort()
            suiteSelectSuites.options.add(new Option("All", "All"));
            suiteNames.forEach(suiteName => {
                suiteSelectSuites.options.add(new Option(suiteName, suiteName));
            });
            suiteSelectSuites.selectedIndex = 1;
        }

        // function to update the available suites to select in the test filters
        function setup_suites_in_test_select() {
            const suiteSelectTests = document.getElementById("suiteSelectTests");
            suiteSelectTests.innerHTML = "";
            const suiteNames = useSuitePathsTestSection
                ? [...new Set(filteredSuites.map(suite => suite.full_name))].sort()
                : [...new Set(filteredSuites.map(suite => suite.name))].sort();
            suiteSelectTests.options.add(new Option("All", "All"));
            suiteNames.forEach(suiteName => {
                suiteSelectTests.options.add(new Option(suiteName, suiteName));
            });
            suiteSelectTests.selectedIndex = 1;
        }

        // function to update the available tests to select in the filters
        // applies to the test filter on the test statistics level
        function setup_tests_in_select() {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const testSelect = document.getElementById("testSelect");
            testSelect.innerHTML = "";
            const testNames = filteredTests.reduce((names, test) => {
                const isInSuite = useSuitePathsTestSection
                    ? test.full_name.includes(`${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All"
                    : test.full_name.includes(`.${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All"
                const hasTag = testTagsSelect === "All" || test.tags.includes(testTagsSelect);

                if (isInSuite && hasTag && !names.includes(test.name)) {
                    names.push(test.name);
                }

                return names;
            }, []);
            testSelect.options.add(new Option("All", "All"));
            testNames.forEach(testName => testSelect.options.add(new Option(testName, testName)));
        }

        // function to update the available testtags to select in the filters
        // applies to the testtag filter on the test statistics level
        function setup_testtags_in_select() {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect");
            testTagsSelect.innerHTML = "";
            const testTags = [...new Set(filteredTests.reduce((tags, test) => {
                if (useSuitePathsTestSection) {
                    if (test.full_name.includes(`${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All") {
                        test.tags.replace(/\[|\]/g, "").split(",").forEach(tag => tags.push(tag.trim()));
                    }
                } else {
                    if (test.full_name.includes(`.${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All") {
                        test.tags.replace(/\[|\]/g, "").split(",").forEach(tag => tags.push(tag.trim()));
                    }
                }
                return tags;
            }, []))].filter(Boolean);
            testTagsSelect.options.add(new Option("All", "All"));
            testTags.forEach(tag => testTagsSelect.options.add(new Option(tag, tag)));
        }

        // function to update the available keywords to select in the filters
        // applies to the keyword filter on the keyword statistics level
        function setup_keywords_in_select() {
            const keywordSelect = document.getElementById("keywordSelect");
            keywordSelect.innerHTML = "";
            const keywordNames = [...new Set(filteredKeywords.map(keyword => keyword.name))].sort();
            keywordNames.forEach(keywordName => keywordSelect.options.add(new Option(keywordName, keywordName)));
            keywordSelect.selectedIndex = keywordNames.length - 1;
        }

        ///////////////////////////
        // DATA FILTER FUNCTIONS //
        ///////////////////////////

        // function to remove milliseconds if needed
        function remove_milliseconds(data) {
            if (showMilliseconds) { return data; }

            return data.map(obj => ({
                ...obj,
                run_start: obj.run_start.slice(0, 19)
            }));
        }

        // function to filter run data based on the runs (aka run name) filter
        function filter_runs(runs) {
            const selectedRun = document.getElementById("runs").value;
            // If "All" is selected, return the original array of runs
            if (selectedRun === "All") {
                var selectedRuns = runs
            } else {
                var selectedRuns = Object.values(runs).filter(run => run.name === selectedRun)
            }
            return selectedRuns;
        }

        // function to filter run data based on the run tags filter
        function filter_runtags(runs) {
            const tagElements = document.getElementById("runTag").getElementsByTagName("input");
            const useOrTags = document.getElementById("useOrTags").checked;
            const selectedTags = Array.from(tagElements)
                .filter(tagElement => tagElement.checked)
                .map(tagElement => tagElement.id);
            if (selectedTags.includes("All")) { // If "All" is selected, return all runs
                return runs;
            }
            if (selectedTags.length === 0) { // If no tags are selected, return an empty list
                return [];
            }
            return runs.filter(run => {
                const runTags = run.tags.split(",");
                if (!useOrTags) { // Use AND logic: the run must contain all selected tags
                    return selectedTags.every(selectedTag => runTags.includes(selectedTag));
                }
                // Use OR logic: the run must contain at least one selected tag
                return selectedTags.some(selectedTag => runTags.includes(selectedTag));
            });
        }

        // function to filter the run data based on the selected date range
        function filter_dates(runs) {
            const fromDate = document.getElementById("fromDate").value;
            const fromTime = document.getElementById("fromTime").value;
            const toDate = document.getElementById("toDate").value;
            const toTime = document.getElementById("toTime").value;
            if (!fromDate || !fromTime || !toDate || !toTime) { // Return all runs if any date/time values are missing
                return runs;
            }
            const fromDateTime = new Date(`${fromDate} ${fromTime}:00`);
            const toDateTime = new Date(`${toDate} ${toTime}:00`);
            if (fromDateTime > toDateTime) { // Check for valid date range
                alert("Filter error: The selected from date + time is later than your selected to date + time. Date filter has not been applied!");
                return runs;  // Return all runs if invalid range
            }
            return runs.filter(run => {
                const runStart = new Date(run.run_start);
                return runStart >= fromDateTime && runStart <= toDateTime;
            });
        }

        // function to filter the amount of runs based on the filter
        function filter_amount(filteredRuns) {
            var selectedAmount = document.getElementById("amount").value;
            // Handle weird selectedAmountValues:
            if (selectedAmount == "") {
                $("#amount").val(10).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount > runs.length) {
                $("#amount").val(runs.length).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount < 0) {
                $("#amount").val(0).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount.includes(",")) {
                $("#amount").val(selectedAmount.split(",")[0]).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount.includes(".")) {
                $("#amount").val(selectedAmount.split(".")[0]).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            filteredAmount = filteredRuns.length
            if (selectedAmount == 0) { return [] }
            filteredRuns = filteredRuns.slice(- selectedAmount)
            return filteredRuns
        }

        // function to filter suites/tests/keywords based on the already filtered runs
        function filter_data(data) {
            var validRunStarts = [];
            for (value of filteredRuns) {
                validRunStarts.push(value.run_start);
            }
            var filteredData = [];
            for (value of data) {
                if (validRunStarts.includes(value.run_start)) {
                    filteredData.push(value);
                }
            }
            return filteredData;
        }

        //////////////////////////////////////
        // GRAPH & TABLE CREATION FUNCTIONS //
        //////////////////////////////////////

        // function to create run statistics graph in the run section
        function create_run_statistics_graph() {
            if (runStatisticsGraph) {
                runStatisticsGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_statistics_graph_data("run", runStatisticsGraphType, filteredRuns);
            const graphData = data[0]
            var config;
            if (runStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Amount Of Tests", "Date", "Amount", false);
            } else if (runStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Run Statistics", "Run", "Amount Of Tests");
            } else if (runStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Run Statistics", "Run", "Percentage");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            runStatisticsGraph = new Chart("runStatisticsGraph", config);
            runStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(runStatisticsGraph, event)
            });
        }

        // function to create run donut graph in the run section
        function create_run_donut_graph() {
            if (runDonutGraph) {
                runDonutGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_donut_graph_data("run", filteredRuns);
            const graphData = data[0]
            const callbackData = data[1]
            var config = get_graph_config("donut", graphData, `Last Run Status: ${callbackData}`);
            config.options.onClick = (event, chartElement) => {
                if (chartElement.length) {
                    open_log_file(event, chartElement, callbackData)
                }
            };
            runDonutGraph = new Chart("runDonutGraph", config);
        }

        // function to create run donut graph in the run section
        function create_run_donut_total_graph() {
            if (runDonutTotalGraph) {
                runDonutTotalGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_donut_total_graph_data("run", filteredRuns);
            const graphData = data[0]
            const callbackData = data[1]
            var config = get_graph_config("donut", graphData, `Total Status`);
            delete config.options.onClick;
            runDonutTotalGraph = new Chart("runDonutTotalGraph", config);
        }

        // function to create the run stats section in the run section
        function create_run_stats_graph() {
            const data = get_stats_data(filteredRuns, filteredSuites, filteredTests, filteredKeywords);
            document.getElementById('totalRuns').innerText = data.totalRuns
            document.getElementById('totalSuites').innerText = data.totalSuites
            document.getElementById('totalTests').innerText = data.totalTests
            document.getElementById('totalKeywords').innerText = data.totalKeywords
            document.getElementById('totalUniqueTests').innerText = data.totalUniqueTests
            document.getElementById('totalPassed').innerText = data.totalPassed
            document.getElementById('totalFailed').innerText = data.totalFailed
            document.getElementById('totalSkipped').innerText = data.totalSkipped
            document.getElementById('totalRunTime').innerText = data.totalRunTime
            document.getElementById('averageRunTime').innerText = data.averageRunTime
            document.getElementById('averageTestTime').innerText = data.averageTestTime
            document.getElementById('averagePassRate').innerText = data.averagePassRate
        }

        // function to create run duration graph in the run section
        function create_run_duration_graph() {
            if (runDurationGraph) {
                runDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("run", runDurationGraphType, "elapsed_s", filteredRuns);
            var config;
            if (runDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Run Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (runDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Run Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            runDurationGraph = new Chart("runDurationGraph", config);
            runDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(runDurationGraph, event)
            });
        }

        // function to create the run heatmap
        function create_run_heatmap_graph() {
            if (runHeatmapGraph) {
                runHeatmapGraph.destroy();
            }
            const data = get_heatmap_graph_data(filteredTests);
            const graphData = data[0]
            const callbackData = data[1]
            var config = get_graph_config("heatmap", graphData, `Heatmap Graph`, "Hour", "Day");
            delete config.options.onClick;
            config.options.plugins.tooltip = {
                callbacks: {
                    title: () => null,
                    label: ctx => {
                        const { x, y, v } = ctx.raw;
                        if (heatMapHourAll) {
                            return `Day: ${callbackData[Math.floor(y - 0.5)]}, Hour: ${Math.floor(x - 0.5)}, Amount: ${v}`;
                        } else { 
                            return `Day: ${callbackData[Math.floor(y - 0.5)]}, Minute: ${Math.floor(x - 0.5)}, Amount: ${v}`;
                        }
                    }
                }
            }
            config.options.scales.y.ticks = {
                stepSize: 1,
                callback: val => callbackData[val] || ''
            }
            runHeatmapGraph = new Chart("runHeatmapGraph", config);
        }

        // function to create run table in the run section
        function create_run_table() {
            if (runTable) {
                runTable.destroy();
            }
            data = [];
            for (run of filteredRuns) {
                data.push([
                    run.run_start,
                    run.full_name,
                    run.name,
                    run.total,
                    run.passed,
                    run.failed,
                    run.skipped,
                    run.elapsed_s,
                    run.start_time,
                    run.tags,
                    run.run_alias,
                ]);
            }
            runTable = new DataTable("#runTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "tags" },
                    { title: "alias" }
                ],
                data: data,
            });
        }

        // function to create suite folder donut
        function create_suite_folder_donut_graph(folder) {
            const suiteFolder = document.getElementById("suiteFolder")
            suiteFolder.innerText = folder == "" || folder == undefined ? "All" : folder;
            if (folder || folder == "") { // not first load so update the graphs accordingly as well
                setup_suites_in_suite_select();
                create_suite_folder_fail_donut_graph();
                create_suite_statistics_graph();
                create_suite_duration_graph();
            }
            if (suiteFolderDonutGraph) {
                suiteFolderDonutGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_donut_folder_graph_data("suite", filteredSuites, folder);
            const graphData = data[0]
            const callbackData = data[1]
            const labels = graphData.labels
            var config = get_graph_config("donut", graphData, `All Folder Statistics`);
            config.options.plugins.tooltip.callbacks = {
                label: function (context) {
                    const label = labels[context.dataIndex]
                    const passed = callbackData[label].passed
                    const failed = callbackData[label].failed
                    const skipped = callbackData[label].skipped
                    return [`Total: ${context.raw}`, `Passed: ${passed}`, `Failed: ${failed}`, `Skipped: ${skipped}`];
                },
                title: function (tooltipItem) {
                    return tooltipItem.label;
                }
            }
            config.options.onClick = (event) => {
                if (event.chart.tooltip.title) {
                    setTimeout(() => {
                        create_suite_folder_donut_graph(event.chart.tooltip.title[0]);
                    }, 0);
                }
            };
            suiteFolderDonutGraph = new Chart("suiteFolderDonutGraph", config);
        }

        // function to create suite last failed donut
        function create_suite_folder_fail_donut_graph() {
            if (suiteFolderFailDonutGraph) {
                suiteFolderFailDonutGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_donut_folder_fail_graph_data("suite", filteredSuites);
            const graphData = data[0]
            const callbackData = data[1]
            const labels = graphData.labels
            if (graphData.labels.length == 0) {
                graphData.labels = ["No Failed Folders In Last Run"]
                graphData.datasets = [{
                    data: [1],
                    backgroundColor: ["grey"],
                }]
            }
            var config = get_graph_config("donut", graphData, `Last Run Failed Folders`);
            config.options.plugins.tooltip.callbacks = {
                label: function (context) {
                    if (context.label == "No Failed Folders In Last Run") { return null }
                    const label = labels[context.dataIndex]
                    const passed = callbackData[label].passed
                    const failed = callbackData[label].failed
                    const skipped = callbackData[label].skipped
                    return [`Passed: ${passed}`, `Failed: ${failed}`, `Skipped: ${skipped}`];
                },
                title: function (tooltipItem) {
                    return tooltipItem.label;
                }
            }
            config.options.plugins.datalabels = {
                ...dataLabelConfig,
                formatter: function (value, context) {
                    if (value === 0) return null;
                    const total = graphData.datasets[0].data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    if (percentage <= 5) return null;
                    const label = graphData.labels[context.dataIndex].split(".").pop();
                    return `${label}: ${value} (${percentage}%)`;
                }
            };
            config.options.onClick = (event) => {
                if (event.chart.tooltip.title) {
                    setTimeout(() => {
                        create_suite_folder_donut_graph(event.chart.tooltip.title[0]);
                    }, 0);
                }
            };
            suiteFolderFailDonutGraph = new Chart("suiteFolderFailDonutGraph", config);
        }

        // function to create suite statistics graph in the suite section
        function create_suite_statistics_graph() {
            if (suiteStatisticsGraph) {
                suiteStatisticsGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_statistics_graph_data("suite", suiteStatisticsGraphType, filteredSuites);
            const graphData = data[0]
            const callbackData = data[1]
            var config;
            if (suiteStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Amount Of Tests", "Date", "amount", false);
                config.options.plugins.tooltip = {
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            } else if (suiteStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Suite Statistics", "Run", "Amount Of Tests");
                const filter = config.options.plugins.tooltip.filter
                config.options.plugins.tooltip = {
                    filter,
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            } else if (suiteStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Suite Statistics", "Run", "Percentage");
                const filter = config.options.plugins.tooltip.filter
                config.options.plugins.tooltip = {
                    filter,
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            suiteStatisticsGraph = new Chart("suiteStatisticsGraph", config);
            suiteStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(suiteStatisticsGraph, event)
            });
        }

        // function to create suite duration graph in the suite section
        function create_suite_duration_graph() {
            if (suiteDurationGraph) {
                suiteDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("suite", suiteDurationGraphType, "elapsed_s", filteredSuites);
            var config;
            if (suiteDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Suite Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (suiteDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Suite Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            suiteDurationGraph = new Chart("suiteDurationGraph", config);
            suiteDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(suiteDurationGraph, event)
            });
        }

        // function to create suite most failed graph in the suite section
        function create_suite_most_failed_graph() {
            if (suiteMostFailedGraph) {
                suiteMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("suite", suiteMostFailedGraphType, filteredSuites, false);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (suiteMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Failed Suites`, "Suite", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (suiteMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Failed Suites`, "Run", "Suite");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("suiteMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, suiteMostFailedGraphType);
            suiteMostFailedGraph = new Chart("suiteMostFailedGraph", config);
            suiteMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(suiteMostFailedGraph, event)
            });
        }

        // function to create suite table in the suite section
        function create_suite_table() {
            if (suiteTable) {
                suiteTable.destroy();
            }
            data = [];
            for (suite of filteredSuites) {
                data.push([
                    suite.run_start,
                    suite.full_name,
                    suite.name,
                    suite.total,
                    suite.passed,
                    suite.failed,
                    suite.skipped,
                    suite.elapsed_s,
                    suite.start_time,
                    suite.run_alias,
                    suite.id,
                ]);
            }
            suiteTable = new DataTable("#suiteTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "alias" },
                    { title: "id" },
                ],
                data: data,
            });
        }

        // function to create test statistics graph in the test section
        function create_test_statistics_graph() {
            if (testStatisticsGraph) {
                testStatisticsGraph.destroy();
            }
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            var [labels, runStarts, datasets] = [[], [], []];
            for (test of filteredTests) {
                if (useSuitePathsTestSection) {
                    if (suiteSelectTests != "All" && test.full_name != `${suiteSelectTests}.${test.name}`) {
                        continue;
                    }
                } else {
                    if (suiteSelectTests != "All" && !test.full_name.includes(`.${suiteSelectTests}.${test.name}`) && test.full_name != `${suiteSelectTests}.${test.name}`) {
                        continue;
                    }
                }
                if (testSelect != "All" && test.name != testSelect) {
                    continue;
                }
                if (testTagsSelect != "All" && !test.tags.replace(/\[|\]/g, "").split(",").includes(testTagsSelect)) {
                    continue
                }
                if (!labels.includes(test.name)) {
                    labels.push(test.name);
                }
                if (showAliases) {
                    if (!runStarts.includes(test.run_alias)) {
                        runStarts.push(test.run_alias);
                    }
                    var runAxis = runStarts.indexOf(test.run_alias)
                } else {
                    if (!runStarts.includes(test.run_start)) {
                        runStarts.push(test.run_start);
                    }
                    var runAxis = runStarts.indexOf(test.run_start)
                }
                if (test.passed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        ...passedConfig,
                    });
                } else if (test.failed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        ...failedConfig,
                    });
                } else if (test.skipped == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        ...skippedConfig,
                    });
                }
            }
            datasets = convert_timeline_data(datasets)
            var graphData = {
                labels: labels,
                datasets: datasets,
            };
            var config = get_graph_config("timeline", graphData, "Test Statistics", "Run", "Test");
            config.options.plugins.tooltip = {
                callbacks: {
                    label: function (context) {
                        return runStarts[context.raw.x[0]];
                    },
                },
            };
            config.options.scales.x = {
                ticks: {
                    minRotation: 45,
                    maxRotation: 45,
                    stepSize: 1,
                    callback: function (value, index, ticks) {
                        return runStarts[this.getLabelForValue(value)];
                    },
                },
                title: {
                    display: true,
                    text: "Run",
                },
            };
            config.options.onClick = (event, chartElement) => {
                if (chartElement.length) {
                    open_log_file(event, chartElement, runStarts)
                }
            };
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            update_height("testStatisticsVertical", config.data.labels.length, config.options.plugins.title.text, "timeline");
            testStatisticsGraph = new Chart("testStatisticsGraph", config);
            testStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testStatisticsGraph, event)
            });
        }

        // function to create test duration graph in the test section
        function create_test_duration_graph() {
            if (testDurationGraph) {
                testDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("test", testDurationGraphType, "elapsed_s", filteredTests);
            var config;
            if (testDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Test Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (testDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Test Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            testDurationGraph = new Chart("testDurationGraph", config);
            testDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testDurationGraph, event)
            });
        }

        // function to create test messages graph in the test section
        function create_test_messages_graph() {
            if (testMessagesGraph) {
                testMessagesGraph.destroy();
            }
            const data = get_messages_data("test", testMessagesGraphType, filteredTests);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testMessagesGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Fail Messages`, "Message", "Times");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                    title: {
                        display: true,
                        text: "Message",
                    },
                };
                delete config.options.onClick
            } else if (testMessagesGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Fail Messages`, "Run", "Message");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                config.options.scales.y.ticks = {
                    callback: function (value, index, ticks) {
                        return this.getLabelForValue(value).slice(0, 40);
                    },
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testMessagesVertical", config.data.labels.length, config.options.plugins.title.text, testMessagesGraphType);
            testMessagesGraph = new Chart("testMessagesGraph", config);
            testMessagesGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testMessagesGraph, event)
            });
        }

        // function to create test duration deviation graph in test section
        function create_test_duration_deviation_graph() {
            if (testDurationDeviationGraph) {
                testDurationDeviationGraph.destroy();
            }
            const graphData = get_duration_deviation_data("test", testDurationDeviationGraphType, filteredTests)
            const config = get_graph_config("boxplot", graphData, "Duration Deviation", "Test", "Duration");
            delete config.options.onClick
            testDurationDeviationGraph = new Chart("testDurationDeviationGraph", config);
            testDurationDeviationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testDurationDeviationGraph, event)
            });
        }

        // function to create test most flaky graph in test section
        function create_test_most_flaky_graph() {
            if (testMostFlakyGraph) {
                testMostFlakyGraph.destroy();
            }
            const data = get_most_flaky_data("test", testMostFlakyGraphType, filteredTests, ignoreSkips, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testMostFlakyGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Flaky Tests Most Status Flips`, "Test", "Status Flips");
                config.options.plugins.legend = false
                delete config.options.onClick
            } else if (testMostFlakyGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Flaky Tests Most Status Flips`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testMostFlakyVertical", config.data.labels.length, config.options.plugins.title.text, testMostFlakyGraphType);
            testMostFlakyGraph = new Chart("testMostFlakyGraph", config);
            testMostFlakyGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testMostFlakyGraph, event)
            });
        }

        // function to create test recent most flaky graph in test section
        function create_test_recent_most_flaky_graph() {
            if (testRecentMostFlakyGraph) {
                testRecentMostFlakyGraph.destroy();
            }
            const data = get_most_flaky_data("test", testRecentMostFlakyGraphType, filteredTests, ignoreSkipsRecent, true);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testRecentMostFlakyGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Recent Most Flaky Tests Most Status Flips`, "Test", "Status Flips");
                config.options.plugins.legend = false
                delete config.options.onClick
            } else if (testRecentMostFlakyGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Recent Most Flaky Tests Most Status Flips`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testRecentMostFlakyVertical", config.data.labels.length, config.options.plugins.title.text, testRecentMostFlakyGraphType);
            testRecentMostFlakyGraph = new Chart("testRecentMostFlakyGraph", config);
            testRecentMostFlakyGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testRecentMostFlakyGraph, event)
            });
        }

        // function to create test most failed graph in the test section
        function create_test_most_failed_graph() {
            if (typeof type === "string") {
                testMostFailedGraphType = type;
            }
            if (testMostFailedGraph) {
                testMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("test", testMostFailedGraphType, filteredTests, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Failed Tests`, "Test", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (testMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Failed Tests`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, testMostFailedGraphType);
            testMostFailedGraph = new Chart("testMostFailedGraph", config);
            testMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testMostFailedGraph, event)
            });
        }

        // function to create test recent most failed graph in the test section
        function create_test_recent_most_failed_graph() {
            if (typeof type === "string") {
                testRecentMostFailedGraphType = type;
            }
            if (testRecentMostFailedGraph) {
                testRecentMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("test", testRecentMostFailedGraphType, filteredTests, true);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testRecentMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Recent Most Failed Tests`, "Test", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (testRecentMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Recent Most Failed Tests`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testRecentMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, testRecentMostFailedGraphType);
            testRecentMostFailedGraph = new Chart("testRecentMostFailedGraph", config);
            testRecentMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testRecentMostFailedGraph, event)
            });
        }

        // function to create test table in the test section
        function create_test_table() {
            if (testTable) {
                testTable.destroy();
            }
            data = [];
            for (test of filteredTests) {
                data.push([
                    test.run_start,
                    test.full_name,
                    test.name,
                    test.passed,
                    test.failed,
                    test.skipped,
                    test.elapsed_s,
                    test.start_time,
                    test.message,
                    test.tags,
                    test.run_alias,
                    test.id
                ]);
            }
            testTable = new DataTable("#testTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "message" },
                    { title: "tags" },
                    { title: "alias" },
                    { title: "id" },
                ],
                data: data,
            });
        }

        // function to keyword statistics graph in the keyword section
        function create_keyword_statistics_graph() {
            if (keywordStatisticsGraph) {
                keywordStatisticsGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_statistics_graph_data("keyword", keywordStatisticsGraphType, filteredKeywords);
            const graphData = data[0]
            var config;
            if (keywordStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Keyword Statistics", "Date", "Amount", false);
            } else if (keywordStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Keyword Statistics", "Run", "Amount");
            } else if (keywordStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Keyword Statistics", "Run", "Percentage");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordStatisticsGraph = new Chart("keywordStatisticsGraph", config);
            keywordStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordStatisticsGraph, event)
            });
        }

        // function to keyword times run graph in the keyword section
        function create_keyword_times_run_graph() {
            if (keywordTimesRunGraph) {
                keywordTimesRunGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordTimesRunGraphType, "times_run", filteredKeywords);
            var config;
            if (keywordTimesRunGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Times Run Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordTimesRunGraphType == "line") {
                config = get_graph_config("line", graphData, "Times Run", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordTimesRunGraph = new Chart("keywordTimesRunGraph", config);
            keywordTimesRunGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordTimesRunGraph, event)
            });
        }

        // function to keyword total time graph in the keyword section
        function create_keyword_total_duration_graph() {
            if (typeof type === "string") {
                keywordTotalDurationGraphType = type;
            }
            if (keywordTotalDurationGraph) {
                keywordTotalDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordTotalDurationGraphType, "total_time_s", filteredKeywords);
            var config;
            if (keywordTotalDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Total Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordTotalDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Total Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordTotalDurationGraph = new Chart("keywordTotalDurationGraph", config);
            keywordTotalDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordTotalDurationGraph, event)
            });
        }

        // function to keyword average time graph in the keyword section
        function create_keyword_average_duration_graph() {
            if (keywordAverageDurationGraph) {
                keywordAverageDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordAverageDurationGraphType, "average_time_s", filteredKeywords);
            var config;
            if (keywordAverageDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Average Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordAverageDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Average Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordAverageDurationGraph = new Chart("keywordAverageDurationGraph", config);
            keywordAverageDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordAverageDurationGraph, event)
            });
        }

        // function to keyword min time graph in the keyword section
        function create_keyword_min_duration_graph() {
            if (keywordMinDurationGraph) {
                keywordMinDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordMinDurationGraphType, "min_time_s", filteredKeywords);
            var config;
            if (keywordMinDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Min Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordMinDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Min Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordMinDurationGraph = new Chart("keywordMinDurationGraph", config);
            keywordMinDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordMinDurationGraph, event)
            });
        }

        // function to keyword max time graph in the keyword section
        function create_keyword_max_duration_graph() {
            if (keywordMaxDurationGraph) {
                keywordMaxDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordMaxDurationGraphType, "max_time_s", filteredKeywords);
            var config;
            if (keywordMaxDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Max Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordMaxDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Max Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordMaxDurationGraph = new Chart("keywordMaxDurationGraph", config);
            keywordMaxDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordMaxDurationGraph, event)
            });
        }

        // function to create test most failed graph in the test section
        function create_keyword_most_failed_graph() {
            if (typeof type === "string") {
                keywordMostFailedGraphType = type;
            }
            if (keywordMostFailedGraph) {
                keywordMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("keyword", keywordMostFailedGraphType, filteredKeywords, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (keywordMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Failed Keywords`, "Keyword", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (keywordMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Failed Keywords`, "Run", "Keyword");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("keywordMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, keywordMostFailedGraphType);
            keywordMostFailedGraph = new Chart("keywordMostFailedGraph", config);
            keywordMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordMostFailedGraph, event)
            });
        }

        // function to keyword table in the keyword section
        function create_keyword_table() {
            if (keywordTable) {
                keywordTable.destroy();
            }
            data = [];
            for (keyword of filteredKeywords) {
                data.push([
                    keyword.run_start,
                    keyword.name,
                    keyword.passed,
                    keyword.failed,
                    keyword.skipped,
                    keyword.times_run,
                    keyword.total_time_s,
                    keyword.average_time_s,
                    keyword.min_time_s,
                    keyword.max_time_s,
                    keyword.run_alias,
                ]);
            }
            keywordTable = new DataTable("#keywordTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "times_run" },
                    { title: "total_execution_time" },
                    { title: "average_execution_time" },
                    { title: "min_execution_time" },
                    { title: "max_execution_time" },
                    { title: "alias" },
                ],
                data: data,
            });
        }

        ///////////////////////////////////
        // GRAPH DATA & CONFIG FUNCTIONS //
        ///////////////////////////////////

        // function to open the log when clicking on the labels
        function open_log_from_label(chart, click) {
            if (!use_logs) { return }
            let resetCoordinates = chart.canvas.getBoundingClientRect();
            const xCoor = click.clientX - resetCoordinates.left;
            const yCoor = click.clientY - resetCoordinates.top;
            const { data, scales: { x: { top, bottom, left, height, width, ticks } } } = chart;
            const right = width / ticks.length;

            for (let i = 0; i < ticks.length; i++) {
                if (xCoor >= left + (right * i) && xCoor <= left + right + (right * i) && yCoor >= top && yCoor <= bottom) {
                    var run
                    const identifier = chart.config._config.options.indexAxis === "y" ? Object.values(ticks).map(item => item.label) : data.labels // exception for timelines
                    if (showAliases) {
                        run = runs.find(run => run.run_alias === identifier[i])
                    } else {
                        run = runs.find(run => run.run_start === identifier[i])
                    }
                    if (run) {
                        const path = transform_file_path(run.path)
                        if (path == "") {
                            alert("Log file error: this output didn't have a path in the database so the log file cannot be found!");
                            return
                        }
                        var fileUrl = ""
                        if (server) { // server url
                            fileUrl = `/log?path=${path}`
                        } else if (window.location.href.includes("file:///")) { // local machine url
                            fileUrl = `file:///${path}`
                        } else { // remote machine file server
                            fileUrl = combine_paths(window.location.href, path)
                        }
                        const win = window.open(fileUrl, "_blank")
                    }
                }
            }
        }

        // function to add the suite or test id to the log path url
        function update_log_path_with_id(path, graphId, chartElement, event) {
            if (graphId.includes("run") || graphId.includes("keyword")) {
                return transform_file_path(path)
            } // can"t select a run or keyword in the suite/log log.html
            const graphType = event.chart.config._config.type
            var name = ""
            var id = ""
            var runStart = runs.find(run => run.path === path).run_start
            if (graphId.includes("suite")) {
                if (graphId == "suiteStatisticsGraph") {
                    name = event.chart.tooltip.title[0].split(": ").pop()
                } else if (graphId == "suiteDurationGraph") {
                    name = event.chart.tooltip.body[0].lines[0].split(": ")[0]
                } else if (graphId == "suiteMostFailedGraph") {
                    name = chartElement[0].element.$context.raw.y
                }
                id = suites.find(suite => suite.name === name && suite.run_start === runStart)
            } else { // it contains a test
                if (graphId == "testStatisticsGraph" || graphId == "testMostFlakyGraph" || graphId == "testRecentMostFlakyGraph" || graphId == "testMostFailedGraph" || graphId == "testRecentMostFailedGraph") {
                    name = chartElement[0].element.$context.raw.y
                } else if (graphId == "testDurationGraph") {
                    if (graphType == "bar") {
                        name = event.chart.tooltip.dataPoints[0].dataset.label
                    } else {
                        const datasetIndex = chartElement[0].datasetIndex
                        name = event.chart.legend.legendItems[datasetIndex].text
                    }
                } else { // this exception is for the Test Messages graph as you can"t tell which test it relates to (might be more than 1!)
                    return transform_file_path(path)
                }
                id = tests.find(test => test.name === name && test.run_start === runStart)
            }
            if (id == undefined) {
                return transform_file_path(path)
            }
            return `${transform_file_path(path)}#${id.id}`
        }

        // function to open the log files through the graphs
        function open_log_file(event, chartElement, callbackData = undefined) {
            if (!use_logs) { return }
            const graphType = event.chart.config._config.type
            const graphId = event.chart.canvas.id
            var runStart = ""
            if (graphType == "doughnut") {
                runStart = callbackData
            } else if (callbackData) {
                const index = chartElement[0].element.$context.raw.x[0]
                runStart = callbackData[index]
            } else if (graphType == "line" && !graphId.includes("Statistics")) {
                runStart = format_date_to_string(new Date(chartElement[0].element.$context.raw.x))
            } else {
                const index = chartElement[0].index
                runStart = event.chart.data.labels[index]
            }
            var output = runs.find(run => run.run_start.slice(0, 19) === runStart.slice(0, 19))
            var path = output ? output.path : runs.find(run => run.run_alias === runStart).path
            if (path == "") {
                alert("Log file error: this output didn't have a path in the database so the log file cannot be found!");
                return
            }
            path = update_log_path_with_id(path, graphId, chartElement, event)
            var fileUrl = ""
            if (server) { // server url
                fileUrl = `/log?path=${path}`
            } else if (window.location.href.includes("file:///")) { // local machine url
                fileUrl = `file:///${path}`
            } else { // remote machine file server
                fileUrl = combine_paths(window.location.href, path)
            }
            const win = window.open(fileUrl, "_blank")
        }

        // function to retrieve the required graph config for chartjs, based on the different type of graphs
        function get_graph_config(graphType, graphData, graphTitle, xTitle, yTitle, dataSets = true) {
            // Common base config to reduce repetition
            const baseConfig = {
                onClick: (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement)
                    }
                },
                normalized: true,
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    delay: (context) => {
                        const dataLength = context.chart.data.datasets.reduce((largest, current) =>
                            current.data.length > largest.data.length ? current : largest
                        ).data.length;
                        const delay = 1500 / dataLength;
                        return context.dataIndex * delay;
                    },
                },
                plugins: {
                    title: {
                        display: true,
                        text: graphTitle,
                    },
                    datalabels: {
                        display: false,
                    },
                },
            };
            // Common scales configuration
            const commonScales = {
                x: {
                    title: {
                        display: true,
                        text: xTitle,
                    },
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                },
                y: {
                    title: {
                        display: true,
                        text: yTitle,
                    },
                    beginAtZero: true,
                    grace: "5%",
                    ticks: {
                        callback: function (value, index) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                },
            };
            if (dataSets && graphType == "line") {
                graphData = { datasets: graphData };
            }
            var config
            // Configuration for "line" graph
            if (graphType === "line") {
                config = {
                    type: "line",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                type: "time",
                                time: {
                                    tooltipFormat: "dd.MM.yyyy HH:mm:ss",
                                },
                                ticks: {
                                    maxTicksLimit: 10,
                                    minRotation: 45,
                                    maxRotation: 45,
                                    callback: function (value, index) {
                                        return this.getLabelForValue(value).slice(0, 40);
                                    },
                                },
                            },
                        },
                    },
                };
            }
            // Configuration for "bar" graph
            if (graphType === "bar") {
                config = {
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            y: {
                                ...commonScales.y,
                                stacked: true,
                            },
                        },
                        interaction: {
                            mode: "x",
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                filter: (tooltipItem) => tooltipItem.dataset.data[tooltipItem.dataIndex] > 0,
                            },
                            datalabels: {
                                color: "#000000",
                                align: "center",
                                anchor: "center",
                                formatter: (value) => value > 0 ? value : null,
                            },
                        },
                    },
                };
            }
            // Configuration for "timeline" graph
            if (graphType === "timeline") {
                config = {
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        indexAxis: "y",
                        scales: {
                            ...commonScales,
                            y: {
                                ...commonScales.y,
                                stacked: true,
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            legend: {
                                display: false,
                            },
                        },
                    },
                };
            }
            // Configuration for "boxplot" graph
            if (graphType === "boxplot") {
                config = {
                    type: "boxplot",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                ticks: {
                                    minRotation: 45,
                                    maxRotation: 45,
                                    callback: function (value, index) {
                                        return this.getLabelForValue(value).slice(0, 40);
                                    },
                                },
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                enabled: true,
                            },
                            legend: {
                                display: false,
                            },
                        },
                    },
                };
            }
            if (graphType == "donut") {
                config = {
                    type: "doughnut",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        animation: {
                            duration: 2000,
                        },
                        radius: "90%",
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                callbacks: {
                                    title: function (tooltipItem) {
                                        if (tooltipItem[0].element.$datalabels[0]._model) {
                                            return tooltipItem[0].element.$datalabels[0]._model.lines[0];
                                        } else {
                                            return `${tooltipItem[0].label}: ${tooltipItem[0].formattedValue}`
                                        }
                                    }
                                }
                            },
                            legend: {
                                display: true,
                                labels: {
                                    generateLabels: function (chart) {
                                        const dataset = chart.data.datasets[0];
                                        const meta = chart.getDatasetMeta(0);
                                        const labels = chart.data.labels;
                                        const defaultColor = Chart.defaults.color;

                                        return labels.map((label, i) => {
                                            const style = meta.controller.getStyle(i);
                                            const isHidden = !chart.isDatasetVisible(0) || meta.data[i].hidden;

                                            return {
                                                text: label.split('.').pop(),
                                                fillStyle: style.backgroundColor,
                                                strokeStyle: style.borderColor,
                                                lineWidth: style.borderWidth,
                                                lineCap: style.borderCapStyle || 'butt',
                                                lineDash: style.borderDash || [],
                                                lineDashOffset: style.borderDashOffset || 0,
                                                pointStyle: style.pointStyle || 'circle',
                                                rotation: style.rotation || 0,
                                                hidden: isHidden,
                                                index: i,
                                                datasetIndex: 0,
                                                fontColor: defaultColor,
                                                hidden: chart._hiddenIndices?.[i] ?? false,
                                            };
                                        });
                                    }
                                },
                            },
                            datalabels: {
                                ...dataLabelConfig,
                                align: "center",
                                anchor: "center",
                                formatter: function (value, context) {
                                    if (value == 0) { return null }
                                    const total = graphData.datasets[0].data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((value / total) * 100);
                                    if (percentage <= 5) { return null }
                                    const label = graphData.labels[context.dataIndex].split(".").pop()
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            },
                        },
                    },
                };
            }
            if (graphType == 'heatmap') {
                config = {
                    type: 'matrix',
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                min: 0,
                                max: heatMapHourAll ? 24 : 60,
                                offset: false,
                                grid: {
                                    display: true,
                                    drawTicks: true,
                                    tickLength: 8,
                                },
                                ticks: {
                                    minRotation: 45,
                                    maxRotation: 45,
                                    stepSize: 1,
                                    callback: function (val) {
                                        if (heatMapHourAll) {
                                            return `${val}:00`
                                        } else {
                                            const hour = document.getElementById('heatMapHour').value;
                                            return `${('0'+hour).slice(-2)}:${('0'+val).slice(-2)}`
                                        }
                                    },
                                },
                                title: {
                                    display: true,
                                    text: heatMapHourAll ? 'Hour' : "Minute",
                                }
                            },
                            y: {
                                type: 'linear',
                                reverse: true,
                                min: 0,
                                max: 7,
                                offset: false,
                                grid: {
                                    display: true,
                                    drawTicks: true,
                                    tickLength: 8,
                                },
                                title: {
                                    display: true,
                                    text: 'Day'
                                }
                            }
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            legend: {
                                display: false
                            },
                        }
                    }
                }
            }
            if (!showLegends) {
                config.options = config.options || {};
                config.options.plugins = config.options.plugins || {};
                config.options.plugins.legend = config.options.plugins.legend || {};
                config.options.plugins.legend.display = false;
            }
            return config
        }

        // helper function to more easily use the logic of filtering suite graph data based on the selected filters
        // returns true if the value should be excluded, false if it should be included
        function exclude_from_suite_data(dataType, value) {
            if (dataType !== "suite") return false;
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            const suiteSelectSuitesOptions = [...document.getElementById("suiteSelectSuites").options].map(o => o.value);
            const suiteFolder = document.getElementById("suiteFolder").innerText;
            const isFolderAll = suiteFolder === "All";
            const isSuiteAll = suiteSelectSuites === "All";
            const usingSuitePaths = useSuitePathsSuiteSection;

            const folderMatches = (val) => val.full_name === suiteFolder || val.full_name.startsWith(`${suiteFolder}.`);
            const suiteNameMatches = (val) => suiteSelectSuitesOptions.includes(val.name);
            const fullNameMatches = (val) => suiteSelectSuitesOptions.includes(val.full_name);

            if (isFolderAll && isSuiteAll) {
                // All folders, all suites: include all
                return false;
            }
            if (isFolderAll && !isSuiteAll) {
                // All folders, specific suite
                return usingSuitePaths
                    ? value.full_name !== suiteSelectSuites
                    : value.name !== suiteSelectSuites;
            }
            if (!isFolderAll && isSuiteAll) {
                // Specific folder, all suites
                if (!folderMatches(value)) return true;

                return usingSuitePaths
                    ? !fullNameMatches(value)
                    : !suiteNameMatches(value);
            }
            // Specific folder, specific suite
            if (!folderMatches(value)) return true;
            return usingSuitePaths
                ? value.full_name !== suiteSelectSuites
                : value.name !== suiteSelectSuites;
        }

        // function to prepare the data in the correct format for statistics graphs
        function get_statistics_graph_data(dataType, graphType, filteredData) {
            const keywordSelect = document.getElementById("keywordSelect").value;
            const passed = [], failed = [], skipped = [], labels = [], aliases = [], names = [];
            const calculate_percentage = (value, total) => Math.round((value / total) * 100);
            const process_value = (value) => {
                const total = value.passed + value.failed + value.skipped;
                const passedPercentage = calculate_percentage(value.passed, total);
                const failedPercentage = calculate_percentage(value.failed, total);
                const skippedPercentage = calculate_percentage(value.skipped, total);
                passed.push(passedPercentage);
                failed.push(failedPercentage);
                skipped.push(skippedPercentage);
                labels.push(value.run_start);
                aliases.push(value.run_alias);
                names.push(value.name)
            };
            for (const value of filteredData) {
                if (exclude_from_suite_data(dataType, value)) { continue }
                if (dataType === "keyword" && value.name !== keywordSelect) continue;
                // Process percentage-based data
                if (graphType === "percentages") {
                    if (dataType === "keyword") {
                        if (value.name === keywordSelect) {
                            process_value(value);
                        }
                    } else {
                        process_value(value);
                    }
                } else {
                    passed.push(value.passed);
                    failed.push(value.failed);
                    skipped.push(value.skipped);
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    names.push(value.name)
                }
            }
            const finalLabels = graphType !== "line" ? (showAliases ? aliases : labels) : labels;
            const styling = graphType !== "line" ? barConfig : lineConfig;
            const create_data_set = (label, data, backgroundColor, borderColor) => ({
                label,
                data,
                backgroundColor,
                borderColor,
                ...styling,
                stack: graphType === "percentages" || "amount" ? "Stack 0" : undefined,
            });
            const statisticsData = {
                labels: finalLabels,
                datasets: [
                    create_data_set("Failed", failed, failedBackgroundColor, failedBackgroundBorderColor),
                    create_data_set("Skipped", skipped, skippedBackgroundColor, skippedBackgroundBorderColor),
                    create_data_set("Passed", passed, passedBackgroundColor, passedBackgroundBorderColor),
                ],
            };
            return [statisticsData, names];
        }

        // function to prepare the data in the correct format for last run donut graphs
        function get_donut_graph_data(dataType, filteredData) {
            const latest = filteredData[Object.keys(filteredData)[Object.keys(filteredData).length - 1]]
            var labels = [];
            var datasets = [];
            var backgroundColors = [];
            var backgroundBorderColors = [];
            if (latest) {
                if (latest.passed > 0) {
                    labels.push("Passed")
                    datasets.push(latest.passed)
                    backgroundColors.push(passedBackgroundColor)
                    backgroundBorderColors.push(passedBackgroundBorderColor)
                }
                if (latest.failed > 0) {
                    labels.push("Failed")
                    datasets.push(latest.failed)
                    backgroundColors.push(failedBackgroundColor)
                    backgroundBorderColors.push(failedBackgroundBorderColor)
                }
                if (latest.skipped > 0) {
                    labels.push("Skipped")
                    datasets.push(latest.skipped)
                    backgroundColors.push(skippedBackgroundColor)
                    backgroundBorderColors.push(skippedBackgroundBorderColor)
                }
            }
            const graphData = {
                labels: labels,
                datasets: [{
                    data: datasets,
                    backgroundColor: backgroundColors,
                    borderColor: backgroundBorderColors,
                    hoverOffset: 4
                }]
            };
            const callBackData = latest ? showAliases ? latest.run_alias : latest.run_start : ""
            return [graphData, callBackData]
        }

        // function to prepare the data in the correct format for duration graphs
        function get_donut_total_graph_data(dataType, filteredData) {
            let passed = 0, failed = 0, skipped = 0;
            const labels = [], backgroundColors = [], backgroundBorderColors = [];
            for (const value of filteredData) {
                if (value.passed > 0) {
                    if (!labels.includes("Passed")) { labels.push("Passed") };
                    if (!backgroundColors.includes(passedBackgroundColor)) { backgroundColors.push(passedBackgroundColor) };
                    if (!backgroundBorderColors.includes(passedBackgroundBorderColor)) { backgroundBorderColors.push(passedBackgroundBorderColor) };
                    passed = passed + value.passed;
                }
                if (value.failed > 0) {
                    if (!labels.includes("Failed")) { labels.push("Failed") };
                    if (!backgroundColors.includes(failedBackgroundColor)) { backgroundColors.push(failedBackgroundColor) };
                    if (!backgroundBorderColors.includes(failedBackgroundBorderColor)) { backgroundBorderColors.push(failedBackgroundBorderColor) };
                    failed = failed + value.failed;
                }
                if (value.skipped > 0) {
                    if (!labels.includes("Skipped")) { labels.push("Skipped") };
                    if (!backgroundColors.includes(skippedBackgroundColor)) { backgroundColors.push(skippedBackgroundColor) };
                    if (!backgroundBorderColors.includes(skippedBackgroundBorderColor)) { backgroundBorderColors.push(skippedBackgroundBorderColor) };
                    skipped = skipped + value.skipped;
                }
            }
            const graphData = {
                labels: labels,
                datasets: [{
                    data: [passed, failed, skipped],
                    backgroundColor: backgroundColors,
                    borderColor: backgroundBorderColors,
                    hoverOffset: 4
                }]
            };
            const callBackData = labels
            return [graphData, callBackData]
        }

        // function to prepare the data in the correct format for the last failed folders donut
        function get_donut_folder_fail_graph_data(dataType, filteredData) {
            var lastRunStart = filteredData[Object.keys(filteredData)[Object.keys(filteredData).length - 1]]
            if (lastRunStart) {
                lastRunStart = lastRunStart.run_start
            }
            const suiteFolder = document.getElementById("suiteFolder").innerText;
            var labels = new Set()
            const callbackData = {}
            const data = []
            for (const value of filteredData) {
                if (value.run_start != lastRunStart) { continue }
                if (value.failed == 0) { continue }
                if (suiteFolder == "All") {
                    const label = value.full_name.split(".")[0]
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                } else {
                    if (!value.full_name.startsWith(suiteFolder + ".") && value.full_name != suiteFolder) { continue }
                    const label = get_next_folder_level(suiteFolder, value.full_name)
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                }
            }
            labels = [...labels]
            for (const label of labels) {
                data.push(callbackData[label].failed)
            }
            const redShades = [
                "#ce3e01", // base fail color
                "#b13601", // darker burnt orange
                "#992f01", // deep red-orange
                "#7f2600"  // very dark, almost brown-red
            ];
            function assignColors(intoCount) {
                const result = [];
                const colorCount = redShades.length;
                let index = 0;
                for (let i = 0; i < intoCount; i++) {
                    result.push(redShades[index]);
                    index = (index + 1) % colorCount;
                    if (i > 0 && result[i] === result[i - 1]) { // Ensure no same color next to each other
                        index = (index + 1) % colorCount;
                        result[i] = redShades[index];
                    }
                }
                return result;
            }
            const backgroundColor = assignColors(labels.length);
            const graphData = {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: backgroundColor,
                    hoverOffset: 4
                }]
            };
            return [graphData, callbackData];
        }

        // function to prepare the data in the correct format for folder donuts
        function get_donut_folder_graph_data(dataType, filteredData, folder) {
            var labels = new Set()
            const callbackData = {}
            const data = []
            for (const value of filteredData) {
                if (!folder) {
                    const label = value.full_name.split(".")[0]
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                } else {
                    if (!value.full_name.startsWith(folder + ".") && value.full_name != folder) { continue }
                    const label = get_next_folder_level(folder, value.full_name)
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                }
            }
            previousFolder = folder ? folder : "";
            labels = [...labels]
            finalLabels = []
            for (const label of labels) {
                if (onlyFailedFolders) {
                    if (callbackData[label].failed > 0) {
                        finalLabels.push(label)
                        data.push(callbackData[label].failed)
                    }
                } else {
                    finalLabels.push(label)
                    data.push(callbackData[label].total)
                }
            }
            var graphData
            if (onlyFailedFolders) {
                const redShades = [
                    "#ce3e01", // base fail color
                    "#b13601", // darker burnt orange
                    "#992f01", // deep red-orange
                    "#7f2600"  // very dark, almost brown-red
                ];
                function assignColors(intoCount) {
                    const result = [];
                    const colorCount = redShades.length;
                    let index = 0;
                    for (let i = 0; i < intoCount; i++) {
                        result.push(redShades[index]);
                        index = (index + 1) % colorCount;
                        if (i > 0 && result[i] === result[i - 1]) { // Ensure no same color next to each other
                            index = (index + 1) % colorCount;
                            result[i] = redShades[index];
                        }
                    }
                    return result;
                }
                const backgroundColor = assignColors(finalLabels.length);
                graphData = {
                    labels: finalLabels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColor,
                        hoverOffset: 4
                    }]
                };
            } else {
                graphData = {
                    labels: finalLabels,
                    datasets: [{
                        data: data,
                        hoverOffset: 4
                    }]
                };
            }
            return [graphData, callbackData]
        }

        function get_heatmap_graph_data(filteredData) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const type = document.getElementById("heatMapTestType").value; // All, Passed, Failed, Skipped
            const hour = document.getElementById("heatMapHour").value;
            const counts = new Map();
            for (const value of filteredData) {
                if (type !== "All") {
                    const key = type.toLowerCase(); // 'passed', 'failed', 'skipped'
                    if (value[key] != 1) continue;
                }
                const date = new Date(value.start_time);
                if (hour === "All") {
                    const x = date.getHours() + 0.5;
                    const y = date.getDay() + 0.5;
                    const key = `${x},${y}`;
                    counts.set(key, (counts.get(key) || 0) + 1);
                } else {
                    if (date.getHours() != parseInt(hour)) continue;
                    const x = date.getMinutes() + 0.5;
                    const y = date.getDay() + 0.5;
                    const key = `${x},${y}`;
                    counts.set(key, (counts.get(key) || 0) + 1);
                }
                
            }
            const data = Array.from(counts.entries()).map(([key, count]) => {
                const [x, y] = key.split(',').map(Number);
                return { x, y, v: count };
            });
            const baseColors = {
                All: [0, 123, 255], // Blue
                Passed: [151, 189, 97], // Green
                Skipped: [254, 216, 79], // Yellow
                Failed: [206, 62, 1], // Red
            };
            const colorRGB = baseColors[type] || baseColors['All'];
            if (data.length == 0) { return [[], []]}
            const graphData = {
                datasets: [{
                    label: 'Test Execution Heatmap',
                    data: data,
                    backgroundColor(ctx) {
                        const v = ctx.dataset.data[ctx.dataIndex].v;
                        const maxV = Math.max(...ctx.dataset.data.map(d => d.v));
                        let alpha = v / maxV;
                        alpha = Math.max(alpha, 0.2); 
                        return `rgba(${colorRGB[0]}, ${colorRGB[1]}, ${colorRGB[2]}, ${alpha})`;
                    },
                    width: ({ chart }) => (chart.chartArea?.width || 0) / (heatMapHourAll ? 24 : 60) - 1,
                    height: ({ chart }) => (chart.chartArea?.height || 0) / 7 - 1,
                    ...barConfig,
                }]
            };
            return [graphData, days];
        }

        // function to prepare the data in the correct format for duration graphs
        function get_duration_graph_data(dataType, graphType, objectDataAttribute, filteredData) {
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const keywordSelect = document.getElementById("keywordSelect").value;
            const should_include = (value) => {
                if (dataType === "keyword" && value.name !== keywordSelect) return false;
                if (exclude_from_suite_data(dataType, value)) return false;
                if (useSuitePathsTestSection) {
                    if (dataType === "test" && suiteSelectTests !== "All" && value.full_name !== `${suiteSelectTests}.${value.name}`) return false;
                } else {
                    if (dataType === "test" && suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) return false;
                }
                if (dataType === "test" && testSelect !== "All" && value.name !== testSelect) return false;
                if (dataType === "test" && testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, "").split(",").includes(testTagsSelect)) return false;
                return true;
            };
            const limit = inFullscreen ? 100 : 30;
            if (graphType === "bar") {
                const labels = [];
                const data = new Map();
                const aliases = [];
                for (const value of filteredData) {
                    if (!should_include(value)) continue;
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    for (const [key, arr] of data.entries()) {
                        arr.push(key === value.name ? roundedValue : 0); // Append to each dataset
                    }
                    if (!data.has(value.name)) {
                        const arr = Array(labels.length - 1).fill(0); // Fill up to current length
                        arr.push(roundedValue);
                        data.set(value.name, arr);
                    }
                    if (labels.length > limit) break;
                }
                if (showAliases) {
                    labels.length = 0;
                    labels.push(...aliases);
                }
                const graphData = {
                    labels,
                    datasets: Array.from(data.entries()).map(([label, dataset]) => ({
                        label: label.slice(0, 40),
                        data: dataset,
                        stack: "Stack 0",
                        ...barConfig,
                    })),
                };
                return graphData;
            }
            else if (graphType === "line") {
                const labels = [];
                const sets = new Map();
                for (const value of filteredData) {
                    if (!should_include(value)) continue;
                    const name = value.name;
                    const run_start = new Date(value.run_start);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    if (!sets.has(name)) {
                        labels.push(name);
                        sets.set(name, [{ x: run_start, y: roundedValue }]);
                    } else {
                        sets.get(name).push({ x: run_start, y: roundedValue });
                    }
                }
                const datasets = Array.from(sets.entries()).map(([key, values]) => ({
                    label: key.slice(0, 40),
                    fill: false,
                    data: values,
                    ...lineConfig,
                }));
                return datasets;
            }
        }

        // function to prepare the data for the run stats canvas
        function get_stats_data(filteredRuns, filteredSuites, filteredTests, filteredKeywords) {
            const data = {
                totalRuns: Object.keys(filteredRuns).length,
                totalSuites: Object.keys(filteredSuites).length,
                totalTests: Object.keys(filteredTests).length,
                totalKeywords: filteredKeywords.reduce((sum, k) => sum + parseInt(k.times_run), 0),
            };
            const testStats = {
                total: 0,
                passed: 0,
                failed: 0,
                skipped: 0,
                duration: 0,
                names: new Set(),
            };
            for (const test of filteredTests) {
                testStats.total++;
                testStats.names.add(test.name);
                if (test.passed == 1) testStats.passed++;
                if (test.failed == 1) testStats.failed++;
                if (test.skipped == 1) testStats.skipped++;
                testStats.duration += parseFloat(test.elapsed_s);
            }
            data.totalUniqueTests = testStats.names.size;
            data.totalPassed = `${testStats.passed} (${Math.round(testStats.passed / testStats.total * 100)}%)`;
            data.totalFailed = `${testStats.failed} (${Math.round(testStats.failed / testStats.total * 100)}%)`;
            data.totalSkipped = `${testStats.skipped} (${Math.round(testStats.skipped / testStats.total * 100)}%)`;
            let totalRunDuration = 0;
            const passRates = filteredRuns.map(run => {
                totalRunDuration += parseFloat(run.elapsed_s);
                return Math.round((run.passed / run.total) * 100);
            });
            data.totalRunTime = `${Math.round(totalRunDuration)} (s)`;
            data.averageRunTime = `${Math.round(totalRunDuration / data.totalRuns)} (s)`;
            data.averageTestTime = `${Math.round(testStats.duration / testStats.total * 100) / 100} (s)`;
            data.averagePassRate = `${Math.round(passRates.reduce((a, b) => a + b, 0) / passRates.length)}%`;
            return data;
        }

        // function to prepare the data in the correct format for the duration deviation graph
        function get_duration_deviation_data(dataType, graphType, filteredData) {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const data = new Map();
            for (const value of filteredData) {
                if (dataType === "test") {
                    if (useSuitePathsTestSection) {
                        if (suiteSelectTests !== "All" && value.full_name !== `${suiteSelectTests}.${value.name}`) {
                            continue;
                        }
                    } else {
                        if (suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) {
                            continue;
                        }
                    }
                    if (testSelect !== "All" && value.name !== testSelect) {
                        continue;
                    }
                    if (testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, "").split(",").includes(testTagsSelect)) {
                        continue;
                    }
                }
                if (data.has(value.name)) {
                    data.get(value.name).push(value.elapsed_s);
                } else {
                    data.set(value.name, [value.elapsed_s]);
                }
            }
            const labels = [];
            const datasets = [];
            for (const [testName, elapsedTimes] of data.entries()) {
                labels.push(testName);
                datasets.push(elapsedTimes);
            }
            return {
                labels,
                datasets: [{
                    itemRadius: 3,
                    data: datasets
                }],
            };
        }

        // function to prepare the data in the correct format for (recent) most flaky test graph
        function get_most_flaky_data(dataType, graphType, filteredData, ignore, recent) {
            var data = {};
            for (value of filteredData) {
                if (data[value.name]) {
                    data[value.name]["run_starts"].push(value.run_start)
                    var current_status
                    if (value.passed == 1) { current_status = "passed" }
                    else if (value.failed == 1) {
                        current_status = "failed"
                        data[value.name]["failed_run_starts"].push(value.run_start)
                    }
                    else if (!ignore) {
                        if (value.skipped == 1) {
                            current_status = "skipped"
                            data[value.name]["failed_run_starts"].push(value.run_start)
                        }
                    }
                    if (current_status != data[value.name]["previous_status"]) {
                        data[value.name]["flips"] += 1
                        data[value.name]["previous_status"] = current_status
                    }
                } else {
                    var previous_status
                    data[value.name] = {
                        "run_starts": [value.run_start],
                        "flips": 0,
                        "failed_run_starts": []
                    }
                    if (value.passed == 1) { previous_status = "passed" }
                    else if (value.failed == 1) {
                        previous_status = "failed"
                        data[value.name]["failed_run_starts"].push(value.run_start)
                    }
                    else if (!ignore) {
                        if (value.skipped == 1) {
                            previous_status = "skipped"
                            data[value.name]["failed_run_starts"].push(value.run_start)
                        }
                    }
                    data[value.name]["previous_status"] = previous_status
                }
            }
            var sortedData = [];
            for (var test in data) {
                if (data[test].flips > 0) {
                    sortedData.push([test, data[test]]);
                }
            }
            sortedData.sort(function (a, b) {
                return b[1].flips - a[1].flips;
            });
            if (recent) { // do extra filtering to get most recent flaky tests at the top
                sortedData.sort(function (a, b) {
                    return new Date(b[1].failed_run_starts[b[1].failed_run_starts.length - 1]).getTime() - new Date(a[1].failed_run_starts[a[1].failed_run_starts.length - 1]).getTime()
                })
            }
            const limit = inFullscreen ? 50 : 10;
            if (graphType == "bar") {
                var [datasets, labels, count] = [[], [], 0];
                for (key in sortedData) {
                    if (count == limit) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    datasets.push(sortedData[key][1].flips);
                    count += 1;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        ...failedConfig,
                    }],
                };
                return [graphData, data];
            } else if (graphType == "timeline") {
                var [labels, runStarts, count, run_aliases] = [[], [], 0, []];
                for (key in sortedData) {
                    if (count == limit) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    for (runStart of sortedData[key][1].run_starts) {
                        if (!runStarts.includes(runStart)) {
                            runStarts.push(runStart);
                        }
                    }
                    count += 1;
                }
                var datasets = [];
                var runAxis = 0;
                runStarts = runStarts.sort((a, b) => new Date(a).getTime() - new Date(b).getTime())
                for (runStart of runStarts) {
                    for (label of labels) {
                        var foundValues = [];
                        for (value of filteredData) {
                            if (value.name == label && value.run_start == runStart) {
                                foundValues.push(value);
                                if (!run_aliases.includes(value.run_alias)) { run_aliases.push(value.run_alias) }
                            }
                        }
                        if (foundValues.length > 0) {
                            var value = foundValues[0];
                            if (value.passed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    ...passedConfig,
                                });
                            }
                            else if (value.failed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    ...failedConfig,
                                });
                            }
                            else if (value.skipped == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    ...skippedConfig,
                                });
                            }
                        }
                    }
                    runAxis += 1;
                }
                if (showAliases) { runStarts = run_aliases }
                datasets = convert_timeline_data(datasets)
                var graphData = {
                    labels: labels,
                    datasets: datasets,
                };
                return [graphData, runStarts];
            }
        }

        // function to prepare the data in the correct format for most failed graphs
        function get_most_failed_data(dataType, graphType, filteredData, recent) {
            const data = new Map();
            const aliases = new Map();
            for (const value of filteredData) {
                if (value.failed > 0) {
                    if (!data.has(value.name)) {
                        data.set(value.name, []);
                        aliases.set(value.name, []);
                    }
                    data.get(value.name).push(value.run_start);
                    aliases.get(value.name).push(value.run_alias);
                }
            }
            var sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length);
            if (recent) { // Do extra filtering to get most most failed tests at the top
                sortedData = sortedData.slice().sort((a, b) => {
                    const latestA = a[1][a[1].length - 1];
                    const latestB = b[1][b[1].length - 1];
                    if (latestA > latestB) return -1;
                    if (latestA < latestB) return 1;
                    return 0; // Preserve original order if equal (stable sort)
                });
            }
            const limit = inFullscreen ? 50 : 10;
            if (graphType === "bar") {
                const datasets = [];
                const labels = [];
                const runStartsLabels = new Map();
                let count = 0;
                for (const [name, runStarts] of sortedData) {
                    if (count == limit) break;
                    labels.push(name);
                    if (showAliases) {
                        data.set(name, aliases.get(name));
                    }
                    datasets.push(runStarts.length);
                    runStartsLabels.set(name, runStarts)
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        ...failedConfig,
                    }],
                };
                const callbackData = showAliases
                    ? Object.fromEntries(sortedData.map(([name, runs]) => [name, aliases.get(name)]))
                    : Object.fromEntries(sortedData.map(([name, runs]) => [name, runStartsLabels.get(name)]));
                return [graphData, callbackData];
            } else if (graphType === "timeline") {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                for (const [name, runStarts] of sortedData) {
                    if (count == limit) break;
                    labels.push(name);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                var datasets = [];
                let runAxis = 0;
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => value.name === label && value.run_start === runStart && value.failed > 0);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                ...failedConfig,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                datasets = convert_timeline_data(datasets)
                const runStartsArray = showAliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [graphData, runStartsArray];
            }
        }

        // function to prepare the data in the correct format for messages graphs
        function get_messages_data(dataType, graphType, filteredData) {
            const data = new Map();
            const aliases = new Map();
            for (const value of filteredData) {
                if (value.message && (value.failed === 1 || value.skipped === 1)) {
                    if (!data.has(value.message)) {
                        data.set(value.message, []);
                        aliases.set(value.message, []);
                    }
                    data.get(value.message).push(value.run_start);
                    aliases.get(value.message).push(value.run_alias);
                }
            }
            // If there is a message config use that to merge the data
            if (!message_config.includes("placeholder_message_config")) {
                function matches_message_config(str, rule) {
                    rule = rule.replace(/\$\{.*?\}/g, "*") // match any ${something} string
                    var escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"); // escape the test messages to prevent regex mismatches
                    return new RegExp("^" + rule.split("*").map(escapeRegex).join(".*") + "$").test(str);
                }
                for (const config of message_config) {
                    for (const [message, runStarts] of data) {
                        if (message == config) { continue }
                        if (matches_message_config(message, config)) {
                            if (!data.has(config)) {
                                data.set(config, []);
                            }
                            data.get(config).push(...runStarts);
                            data.delete(message)
                        }
                    }
                }

                for (const [message, runStarts] of data) {
                    arrayWithDuplicates = data.get(message)
                    data.set(message, [...new Set(arrayWithDuplicates)])
                }
            }
            const limit = inFullscreen ? 50 : 10;
            const sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length); // Sort messages by failure count
            if (graphType === "bar") {
                const [datasets, labels] = [[], []];
                let count = 0;

                for (const [message, runStarts] of sortedData) {
                    if (count == limit) break;
                    labels.push(message);
                    datasets.push(runStarts.length);
                    if (showAliases) {
                        data.set(message, aliases.get(message));
                    }
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        ...failedConfig,
                    }],
                };
                const callbackData = Object.fromEntries(sortedData.map(([message, runs]) => [message, aliases.get(message)]));
                return [graphData, callbackData];
            } else if (graphType === "timeline") {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                for (const [message, runStarts] of sortedData) { // Collect unique run starts and labels
                    if (count == limit) break;
                    labels.push(message);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                var datasets = [];
                let runAxis = 0;
                function check_label(message, label) {
                    return !message_config.includes("placeholder_message_config")
                        ? matches_message_config(message, label)
                        : message === label;
                }
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => check_label(value.message, label) && value.run_start === runStart);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                ...failedConfig,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                datasets = convert_timeline_data(datasets)
                const runStartsArray = showAliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [graphData, runStartsArray];
            }
        }

        // function to update the height of the test statistics graph and enable scrolling
        function update_height(verticalId, labels, title, graphType) {
            const vertical = document.getElementById(verticalId)
            vertical.style.height = `465px`
            if (labels > 10 && graphType != "bar") {
                // timeline view with more than 10 items -> update height
                const newHeight = 465 + (labels - 10) * 35;
                const parentHeight = parseFloat(getComputedStyle(vertical.parentElement).height) - 59;
                if (inFullscreen && newHeight < parentHeight) {
                    vertical.style.height = `${parentHeight}px`
                } else {
                    vertical.style.height = `${newHeight}px`
                }
            } else if (inFullscreen && graphType != "bar") {
                // not more than 10 items, set the height to fullscreen without scrollbar
                const parentHeight = parseFloat(getComputedStyle(vertical.parentElement).height) - 51;
                vertical.style.height = `${parentHeight}px`
            } else if (inFullscreen && graphType == "bar") {
                // bar chart should have fullscreen height because you get more labels on the horizontal axis
                const parentHeight = parseFloat(getComputedStyle(vertical.parentElement).height) - 59;
                vertical.style.height = `${parentHeight}px`
            }
        }

        // function to convert timeline data to improve performance
        function convert_timeline_data(oldDatasets) {
            const grouped = {};
            for (const dataset of oldDatasets) {
                const segment = dataset.data[0]; // assumes 1 item per dataset
                const status = `${dataset.label}:*:&:.:${dataset.backgroundColor}:*:&:.:${dataset.borderColor}`;
                if (!grouped[status]) {
                    grouped[status] = [];
                }
                grouped[status].push({
                    x: segment.x,
                    y: segment.y,
                });
            }
            const data = Object.entries(grouped)
                .filter(([_, data]) => data.length > 0)
                .map(([status, data]) => ({
                    label: status.split(":*:&:.:")[0],
                    data,
                    backgroundColor: status.split(":*:&:.:")[1],
                    borderColor: status.split(":*:&:.:")[2],
                    ...barConfig,
                    parsing: true
                }));
            return data
        }

        ///////////////////////////////////
        // RENDER DATA & GRAPH FUNCTIONS //
        ///////////////////////////////////

        // function to update all graph data, function is called when updating filters and when the page loads
        function setup_data_and_graphs() {
            lastScrollY = window.scrollY;
            setup_spinner(false)

            // Let the browser render before continuing
            requestAnimationFrame(() => {
                setup_filtered_data_and_filters();
                setup_section_order();
                setup_graph_order();
                setup_collapsables();
                setup_eventlisteners_graph_view_buttons();
                setup_eventlisteners_filter_buttons();

                // Let the browser render again to make the graph animations clean
                requestAnimationFrame(() => {
                    setup_spinner(true);
                    setup_all_graphs();
                    setup_section_buttons();

                    requestAnimationFrame(() => {
                        if (lastScrollY > 0) {
                            window.scrollTo({
                                top: lastScrollY,
                                behavior: "auto"
                            });
                        }
                    })
                })
            });
        }

        // function updates the data in the graphs whenever filters are updated
        function setup_filtered_data_and_filters() {
            filteredRuns = remove_milliseconds(runs)
            filteredSuites = remove_milliseconds(suites)
            filteredTests = remove_milliseconds(tests)
            filteredKeywords = remove_milliseconds(keywords)
            // filter run data
            filteredRuns = filter_runs(filteredRuns);
            filteredRuns = filter_runtags(filteredRuns);
            filteredRuns = filter_dates(filteredRuns);
            filteredRuns = filter_amount(filteredRuns);
            // filter suites and tests based on filtered runs
            filteredSuites = filter_data(filteredSuites);
            filteredTests = filter_data(filteredTests);
            filteredKeywords = filter_data(filteredKeywords);
            // set titles with amount of filtered items
            const runAmount = Object.keys(filteredRuns).length
            const message = `<h6>showing ${runAmount} of ${filteredAmount} runs</h6>`
            document.getElementById("runTitle").innerHTML = `Run Statistics (${runAmount}) ${message}`;
            document.getElementById("suiteTitle").innerHTML = `Suite Statistics (${Object.keys(filteredSuites).length}) ${message}`;
            document.getElementById("testTitle").innerHTML = `Test Statistics (${Object.keys(filteredTests).length}) ${message}`;
            document.getElementById("keywordTitle").innerHTML = `Keyword Statistics (${Object.keys(filteredKeywords).length}) ${message}`;
            // update filters based on data
            setup_suites_in_suite_select();
            setup_suites_in_test_select();
            setup_testtags_in_select();
            setup_tests_in_select();
            setup_keywords_in_select();
        }

        // function that updates all graphs based on the new filtered data and hidden choices
        function setup_all_graphs() {
            create_run_statistics_graph();
            create_run_donut_graph();
            create_run_donut_total_graph();
            create_run_stats_graph();
            create_run_duration_graph();
            create_run_heatmap_graph();
            create_run_table();
            create_suite_statistics_graph();
            create_suite_folder_donut_graph();
            create_suite_folder_fail_donut_graph();
            create_suite_duration_graph();
            create_suite_most_failed_graph();
            create_suite_table();
            create_test_statistics_graph();
            create_test_duration_graph();
            create_test_duration_deviation_graph();
            create_test_messages_graph();
            create_test_most_flaky_graph();
            create_test_recent_most_flaky_graph();
            create_test_most_failed_graph();
            create_test_recent_most_failed_graph();
            create_test_table();
            create_keyword_statistics_graph();
            create_keyword_times_run_graph();
            create_keyword_total_duration_graph();
            create_keyword_average_duration_graph();
            create_keyword_min_duration_graph();
            create_keyword_max_duration_graph();
            create_keyword_most_failed_graph();
            create_keyword_table();
        }

        // function to order the sections according to the localstorage config
        function setup_section_order() {
            var prevId = "#loading"
            const sectionShowList = JSON.parse(localStorage.getItem("sectionShow"));
            for (let section of sectionShowList) {
                var nextId = `#${space_to_camelcase(section + " Section")}`
                document.getElementById(`${space_to_camelcase(section + " Section")}`).hidden = false
                $(nextId).insertAfter(prevId)
                prevId = nextId
            }
            const sectionHideList = JSON.parse(localStorage.getItem("sectionHide"));
            for (let section of sectionHideList) {
                document.getElementById(`${space_to_camelcase(section + " Section")}`).hidden = true
            }
        }

        // function to order the grphs according to the localstorage config
        function setup_graph_order() {
            setup_graphs("Run")
            setup_graphs("Suite")
            setup_graphs("Test")
            setup_graphs("Keyword")
        }

        // function to order the graphs in the sections
        function setup_graphs(section) {
            const lowerCaseSection = section.toLowerCase()
            const sectionDataElement = document.getElementById(lowerCaseSection + "Data")
            const sectionDataHiddenElement = document.getElementById(lowerCaseSection + "DataHidden")
            const sectionDataHiddenTempElement = document.getElementById(lowerCaseSection + "DataHiddenTemp")
            // first move all graphs from the {section}Data element to {section}DataHidden to have a clean start if it is not the first load
            if (sectionDataElement.children.length > 0) {
                sectionDataHiddenElement.innerHTML = sectionDataElement.innerHTML
                sectionDataElement.innerHTML = ""
                // also use the temphidden elements if it"s not empty (they are placed there if they are hidden by the config)
                if (sectionDataHiddenTempElement.children.length > 0) {
                    while (sectionDataHiddenTempElement.children.length > 0) {
                        sectionDataHiddenElement.appendChild(sectionDataHiddenTempElement.children[0]);
                    }
                }
                // exception to handle tables because they are completely altered by the datatables module on creation
                const sectionTableElement = document.getElementById(lowerCaseSection + "TableCanvas")
                sectionTableElement.innerHTML = `<table class="table table-striped" id="${lowerCaseSection}Table"></table>`
            }

            const chevronRow = `<div class="row" id="${lowerCaseSection}Chevron{index}">
                                    <div class="col-auto">
                                        <div class="btn btn-sm collapse-icon" id="${lowerCaseSection}ChevronButton{index}" data-bs-toggle="collapse"
                                            data-bs-target="#${lowerCaseSection}Data{index}" aria-expanded="true" aria-controls="${lowerCaseSection}Data{index}">
                                        </div>
                                    </div>
                                    <div class="col">
                                        <h6 class="sectionTitle">{title}</h6>
                                    </div>
                                </div>`
            const dataRow = `<div class="row collapse show" id="${lowerCaseSection}Data{index}">
                                {canvas}
                            </div>`

            // helper function to create the chevron rows and data rows in the sections
            function position_graph(graph) {
                const camelCaseGraph = space_to_camelcase(graph)
                const graphDataElement = document.getElementById(camelCaseGraph + "Canvas")
                const canvas = graphDataElement.outerHTML
                graphDataElement.remove()

                if (sectionDataElement.lastChild == null) {
                    // no row yet
                    if (graph.includes("Table")) {
                        sectionDataElement.innerHTML = chevronRow
                            .replaceAll("{index}", "1")
                            .replace("{title}", graph)
                            .replace("collapse-icon", "collapse-icon collapsed")
                        sectionDataElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow
                                .replace("{index}", "1")
                                .replace("{canvas}", canvas)
                                .replace("collapse show", "collapse")
                        )
                    } else {
                        sectionDataElement.innerHTML = chevronRow
                            .replaceAll("{index}", "1")
                            .replace("{title}", graph)
                        sectionDataElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow
                                .replace("{index}", "1")
                                .replace("{canvas}", canvas))
                    }
                } else {
                    const lastRow = sectionDataElement.lastChild
                    const index = parseInt(lastRow.id.match(/\d+/)[0], 10) + 1

                    if (graph.includes("Table")) {
                        // tables always start a new row
                        sectionDataElement.insertAdjacentHTML(
                            "beforeend",
                            chevronRow
                                .replaceAll("{index}", `${index}`)
                                .replace("{title}", graph)
                                .replace("collapse-icon", "collapse-icon collapsed")
                        )
                        sectionDataElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow
                                .replace("{index}", `${index}`)
                                .replace("{canvas}", canvas)
                                .replace("collapse show", "collapse")
                        )
                    } else if (lastRow.children.length < maxGraphsPerRow) {
                        const isTableRow = [...lastRow.children].some(child => child.id && child.id.includes("Table"))
                        if (isTableRow) {
                            // current row is a table row, start new row
                            sectionDataElement.insertAdjacentHTML(
                                "beforeend",
                                chevronRow.replaceAll("{index}", `${index}`).replace("{title}", graph)
                            )
                            sectionDataElement.insertAdjacentHTML(
                                "beforeend",
                                dataRow.replace("{index}", `${index}`).replace("{canvas}", canvas)
                            )
                        } else {
                            // add to current row
                            lastRow.insertAdjacentHTML("beforeend", canvas)
                            const titleElement = sectionDataElement.children[sectionDataElement.children.length - 2].querySelector(".sectionTitle")
                            titleElement.innerText += ` & ${graph}`
                        }
                    } else {
                        // max reached so new row
                        sectionDataElement.insertAdjacentHTML(
                            "beforeend",
                            chevronRow.replaceAll("{index}", `${index}`).replace("{title}", graph)
                        )
                        sectionDataElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow.replace("{index}", `${index}`).replace("{canvas}", canvas)
                        )
                    }
                }
            }

            // order the graphs correctly
            const graphShowList = JSON.parse(localStorage.getItem("graphShow"));
            for (let graph of graphShowList) {
                if (graph.startsWith(section)) {
                    position_graph(graph)
                }
            }
            // move the hidden items to temp hidden to keep the HTML available for reconfiguration
            const graphHideList = JSON.parse(localStorage.getItem("graphHide"));
            for (let graph of graphHideList) {
                if (graph.startsWith(section)) {
                    const camelCaseGraph = space_to_camelcase(graph)
                    const graphDataElement = document.getElementById(camelCaseGraph + "Canvas")
                    sectionDataHiddenTempElement.appendChild(graphDataElement)
                }
            }
        }

        ///////////////////////////
        // MAIN FUNCTION ON LOAD //
        ///////////////////////////

        // function that triggers all functions that should be executed when the dashboard is loaded first
        // in the correct order!
        function main() {
            setup_scroll_eventlistener();
            setup_theme();
            setup_stats();
            setup_information_icons();
            setup_customize_view_button_eventlisteners();
            setup_customize_view_arrow_eventlisteners();
            setup_customize_view_local_storage();
            setup_customize_view_content();
            update_customize_view_local_storage();
            setup_eventlisteners_section_filter_buttons();
            setup_run_amount_filter();
            setup_lowest_highest_dates();
            setup_runs_in_select_filter_buttons();
            setup_runtags_in_select_filter_buttons();
            setup_data_and_graphs();
        }

        // trigger of first load
        main()
    </script>
</body>

</html>